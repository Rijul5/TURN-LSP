{"version":3,"sources":["webpack:///../node_modules/@theia/core/src/browser/window/window-service.ts","webpack:///../node_modules/@theia/workspace/src/browser/workspace-preferences.ts","webpack:///../node_modules/@theia/workspace/src/browser/workspace-service.ts","webpack:///../node_modules/@theia/workspace/src/common/index.ts","webpack:///../node_modules/@theia/workspace/src/common/workspace-protocol.ts","webpack:///../node_modules/jsonc-parser/lib/esm/impl/edit.js","webpack:///../node_modules/jsonc-parser/lib/esm/impl/format.js","webpack:///../node_modules/jsonc-parser/lib/esm/impl/parser.js","webpack:///../node_modules/jsonc-parser/lib/esm/impl/scanner.js","webpack:///../node_modules/jsonc-parser/lib/esm/main.js"],"names":[],"mappings":"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CA;AACA,6CAA6C,mFAAmF;AAChI;AACA;AACA;AACA,mCAAmC;AACnC,0BAA0B;AAC1B;AACA;AACA,gGAAgG,4BAA4B,EAAE;AAC9H;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,6BAA6B,qDAAK;AAClC;AACA;AACA,wCAAwC,qDAAK;AAC7C;AACA;AACA;AACA,gBAAgB,sDAAM,WAAW,qCAAqC;AACtE;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4EAA4E;AACzF;AACO;AACP;AACA;AACO;AACP;AACA;AACA,gC;;;;;;;;;;;;ACxKA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACa;AAC6B;AACnC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sEAAsE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kC;;;;;;;;;;;;AClMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACa;AAC6B;AAC1C;AACA;AACA;AACO;AACP,sBAAsB;AACtB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2CAA2C;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,+CAA+C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4BAA4B,aAAa;AACzC,yBAAyB,uEAAuE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kFAAkF;AACvH,SAAS;AACT;AACA,qCAAqC,oFAAoF;AACzH,yCAAyC,qFAAqF;AAC9H,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qCAAqC,iFAAiF;AACtH,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB,uGAAuG;AAC5H;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,yBAAyB,+CAA+C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uCAAuC,2BAA2B;AAClE;AACA;AACA;AACA;AACA;AACO;AACP,uCAAuC,2BAA2B;AAClE;AACA;AACA;AACA,2BAA2B,qDAAqD;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,8DAAa;AAChC;AACA,4CAA4C,4EAA4E,EAAE,gBAAgB,aAAa;AACvJ;AACA;AACA,+CAA+C,iFAAiF,EAAE,gBAAgB,aAAa;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,8DAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;AC3lBA;AAAA;AAAA;AACA;AACA;AACA;AACa;AACb;AACA;AACA;AACA;AACO;AACP,kCAAkC,sBAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kCAAkC,YAAY,EAAE;AAChD;AACA,+BAA+B,cAAc,EAAE;AAC/C,oCAAoC,cAAc,EAAE;AACpD,qCAAqC,oBAAoB,EAAE;AAC3D,qCAAqC,0BAA0B,EAAE;AACjE,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;AC5VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACa;AAC8B;AACP;AACM;AACF;AACxC;AACA;AACA;AACA;AACO,oBAAoB,2DAAqB;AAChD;AACA;AACA;AACO,kBAAkB,wDAAkB;AAC3C;AACA;AACA;AACA;AACO,YAAY,kDAAY;AAC/B;AACA;AACA;AACO,gBAAgB,sDAAgB;AACvC;AACA;AACA;AACO,yBAAyB,+DAAyB;AACzD;AACA;AACA;AACO,uBAAuB,6DAAuB;AACrD;AACA;AACA;AACO,kBAAkB,wDAAkB;AAC3C;AACA;AACA;AACO,mBAAmB,yDAAmB;AAC7C;AACA;AACA;AACO,YAAY,kDAAY;AAC/B;AACA;AACA;AACA;AACA;AACO,oBAAoB,0DAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,mDAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,sDAAgB;AAC3B;AACA;AACA;AACA;AACO;AACP,kCAAkC,QAAQ;AAC1C,eAAe,oDAAc;AAC7B;AACA;AACA;AACA,gC","file":"3.bundle.js","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport { injectable } from 'inversify';\n\n/**\n * Service for opening new browser windows.\n */\nexport const WindowService = Symbol('WindowService');\nexport interface WindowService {\n\n    /**\n     * Opens a new window and loads the content from the given URL.\n     */\n    openNewWindow(url: string): void;\n\n}\n\n@injectable()\nexport class DefaultWindowService implements WindowService {\n\n    openNewWindow(url: string): void {\n        const newWindow = window.open(url);\n        if (newWindow === null) {\n            throw new Error('Cannot open a new window for URL: ' + url);\n        }\n    }\n\n}\n","/********************************************************************************\n * Copyright (C) 2018 Ericsson and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport { interfaces } from 'inversify';\nimport {\n    createPreferenceProxy,\n    PreferenceProxy,\n    PreferenceService,\n    PreferenceSchema,\n    PreferenceContribution\n} from '@theia/core/lib/browser/preferences';\n\nexport const workspacePreferenceSchema: PreferenceSchema = {\n    type: 'object',\n    properties: {\n        'workspace.preserveWindow': {\n            description: 'Enable opening workspaces in current window',\n            type: 'boolean',\n            default: false\n        },\n        'workspace.supportMultiRootWorkspace': {\n            description: 'Enable the multi-root workspace support to test this feature internally',\n            type: 'boolean',\n            default: false\n        }\n    }\n};\n\nexport interface WorkspaceConfiguration {\n    'workspace.preserveWindow': boolean,\n    'workspace.supportMultiRootWorkspace': boolean\n}\n\nexport const WorkspacePreferences = Symbol('WorkspacePreferences');\nexport type WorkspacePreferences = PreferenceProxy<WorkspaceConfiguration>;\n\nexport function createWorkspacePreferences(preferences: PreferenceService): WorkspacePreferences {\n    return createPreferenceProxy(preferences, workspacePreferenceSchema);\n}\n\nexport function bindWorkspacePreferences(bind: interfaces.Bind): void {\n    bind(WorkspacePreferences).toDynamicValue(ctx => {\n        const preferences = ctx.container.get<PreferenceService>(PreferenceService);\n        return createWorkspacePreferences(preferences);\n    }).inSingletonScope();\n\n    bind(PreferenceContribution).toConstantValue({ schema: workspacePreferenceSchema });\n}\n","/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport { injectable, inject, postConstruct } from 'inversify';\nimport URI from '@theia/core/lib/common/uri';\nimport { FileSystem, FileStat } from '@theia/filesystem/lib/common';\nimport { FileSystemWatcher, FileChangeEvent } from '@theia/filesystem/lib/browser/filesystem-watcher';\nimport { WorkspaceServer } from '../common';\nimport { WindowService } from '@theia/core/lib/browser/window/window-service';\nimport { FrontendApplication, FrontendApplicationContribution } from '@theia/core/lib/browser';\nimport { Deferred } from '@theia/core/lib/common/promise-util';\nimport { ILogger, Disposable, DisposableCollection, Emitter, Event } from '@theia/core';\nimport { WorkspacePreferences } from './workspace-preferences';\nimport * as jsoncparser from 'jsonc-parser';\nimport * as Ajv from 'ajv';\n\nexport const THEIA_EXT = 'theia-workspace';\nexport const VSCODE_EXT = 'code-workspace';\n\nexport const IWorkspaceService = Symbol('IWorkspaceService');\nexport interface IWorkspaceService {\n    roots: Promise<FileStat[]>;\n}\n\n/**\n * The workspace service.\n */\n@injectable()\nexport class WorkspaceService implements FrontendApplicationContribution {\n\n    private _workspace: FileStat | undefined;\n\n    private _roots: FileStat[] = [];\n    private deferredRoots = new Deferred<FileStat[]>();\n\n    @inject(FileSystem)\n    protected readonly fileSystem: FileSystem;\n\n    @inject(FileSystemWatcher)\n    protected readonly watcher: FileSystemWatcher;\n\n    @inject(WorkspaceServer)\n    protected readonly server: WorkspaceServer;\n\n    @inject(WindowService)\n    protected readonly windowService: WindowService;\n\n    @inject(ILogger)\n    protected logger: ILogger;\n\n    @inject(WorkspacePreferences)\n    protected preferences: WorkspacePreferences;\n\n    @postConstruct()\n    protected async init(): Promise<void> {\n        const workspaceUri = await this.server.getMostRecentlyUsedWorkspace();\n        const workspaceFileStat = await this.toFileStat(workspaceUri);\n        await this.setWorkspace(workspaceFileStat);\n\n        this.watcher.onFilesChanged(event => {\n            if (this._workspace && FileChangeEvent.isAffected(event, new URI(this._workspace.uri))) {\n                this.updateWorkspace();\n            }\n        });\n        this.preferences.onPreferenceChanged(event => {\n            const multiRootPrefName = 'workspace.supportMultiRootWorkspace';\n            if (event.preferenceName === multiRootPrefName) {\n                this.updateWorkspace();\n            }\n        });\n    }\n\n    get roots(): Promise<FileStat[]> {\n        return this.deferredRoots.promise;\n    }\n    tryGetRoots(): FileStat[] {\n        return this._roots;\n    }\n    get workspace(): FileStat | undefined {\n        return this._workspace;\n    }\n\n    protected readonly onWorkspaceChangeEmitter = new Emitter<FileStat[]>();\n    get onWorkspaceChanged(): Event<FileStat[]> {\n        return this.onWorkspaceChangeEmitter.event;\n    }\n\n    protected readonly toDisposeOnWorkspace = new DisposableCollection();\n    protected async setWorkspace(workspaceStat: FileStat | undefined): Promise<void> {\n        if (FileStat.equals(this._workspace, workspaceStat)) {\n            return;\n        }\n        this.toDisposeOnWorkspace.dispose();\n        this._workspace = workspaceStat;\n        if (this._workspace) {\n            this.toDisposeOnWorkspace.push(await this.watcher.watchFileChanges(new URI(this._workspace.uri)));\n        }\n        this.updateTitle();\n        await this.updateWorkspace();\n    }\n\n    protected async updateWorkspace(): Promise<void> {\n        await this.updateRoots();\n        this.watchRoots();\n    }\n\n    protected async updateRoots(): Promise<void> {\n        this._roots = await this.computeRoots();\n        this.deferredRoots.resolve(this._roots); // in order to resolve first\n        this.deferredRoots = new Deferred<FileStat[]>();\n        this.deferredRoots.resolve(this._roots);\n        this.onWorkspaceChangeEmitter.fire(this._roots);\n    }\n\n    protected async computeRoots(): Promise<FileStat[]> {\n        const roots: FileStat[] = [];\n        if (this._workspace) {\n            if (this._workspace.isDirectory) {\n                return [this._workspace];\n            }\n\n            const workspaceData = await this.getWorkspaceDataFromFile();\n            if (workspaceData) {\n                for (const { path } of workspaceData.folders) {\n                    const valid = await this.toValidRoot(path);\n                    if (valid) {\n                        roots.push(valid);\n                    } else {\n                        roots.push({\n                            uri: path,\n                            lastModification: Date.now(),\n                            isDirectory: true\n                        });\n                    }\n                }\n            }\n        }\n        return roots;\n    }\n\n    protected async getWorkspaceDataFromFile(): Promise<WorkspaceData | undefined> {\n        if (this._workspace && await this.fileSystem.exists(this._workspace.uri)) {\n            if (this._workspace.isDirectory) {\n                return {\n                    folders: [{ path: this._workspace.uri }]\n                };\n            }\n            const { stat, content } = await this.fileSystem.resolveContent(this._workspace.uri);\n            const strippedContent = jsoncparser.stripComments(content);\n            const data = jsoncparser.parse(strippedContent);\n            if (data && WorkspaceData.is(data)) {\n                return WorkspaceData.transformToAbsolute(data, stat);\n            }\n            this.logger.error(`Unable to retrieve workspace data from the file: '${this._workspace.uri}'. Please check if the file is corrupted.`);\n        }\n    }\n\n    protected updateTitle(): void {\n        if (this._workspace) {\n            const uri = new URI(this._workspace.uri);\n            const displayName = uri.displayName;\n            if (!this._workspace.isDirectory &&\n                (displayName.endsWith(`.${THEIA_EXT}`) || displayName.endsWith(`.${VSCODE_EXT}`))) {\n                document.title = displayName.slice(0, displayName.lastIndexOf('.'));\n            } else {\n                document.title = displayName;\n            }\n        } else {\n            document.title = window.location.href;\n        }\n    }\n\n    /**\n     * on unload, we set our workspace root as the last recently used on the backend.\n     * @param app\n     */\n    onStop(app: FrontendApplication): void {\n        this.server.setMostRecentlyUsedWorkspace(this._workspace ? this._workspace.uri : '');\n    }\n\n    async recentWorkspaces(): Promise<string[]> {\n        return this.server.getRecentWorkspaces();\n    }\n\n    /**\n     * Returns `true` if current workspace root is set.\n     * @returns {boolean}\n     */\n    get opened(): boolean {\n        return !!this._workspace;\n    }\n\n    /**\n     * Returns `true` if there is an opened workspace in theia, and the workspace has more than one root.\n     * @returns {boolean}\n     */\n    get isMultiRootWorkspaceOpened(): boolean {\n        return this.opened && this.preferences['workspace.supportMultiRootWorkspace'];\n    }\n\n    /**\n     * Opens directory, or recreates a workspace from the file that `uri` points to.\n     */\n    open(uri: URI, options?: WorkspaceInput): void {\n        this.doOpen(uri, options);\n    }\n\n    protected async doOpen(uri: URI, options?: WorkspaceInput): Promise<void> {\n        const rootUri = uri.toString();\n        const stat = await this.toFileStat(rootUri);\n        if (stat) {\n            // The same window has to be preserved too (instead of opening a new one), if the workspace root is not yet available and we are setting it for the first time.\n            // Option passed as parameter has the highest priority (for api developers), then the preference, then the default.\n            await this.roots;\n            const { preserveWindow } = {\n                preserveWindow: this.preferences['workspace.preserveWindow'] || !this.opened,\n                ...options\n            };\n            await this.server.setMostRecentlyUsedWorkspace(rootUri);\n            if (preserveWindow) {\n                this._workspace = stat;\n            }\n            await this.openWindow(stat, { preserveWindow });\n            return;\n        }\n        throw new Error('Invalid workspace root URI. Expected an existing directory location.');\n    }\n\n    /**\n     * Adds a root folder to the workspace\n     * @param uri URI of the root folder being added\n     */\n    async addRoot(uri: URI): Promise<void> {\n        await this.roots;\n\n        if (!this.opened) {\n            throw new Error('Folder cannot be added as there is no active workspace or opened folder.');\n        }\n        const valid = await this.toValidRoot(uri);\n        if (!valid) {\n            throw new Error(`Invalid workspace root URI. Expected an existing directory location. URI: ${uri.toString()}.`);\n        }\n\n        if (this._workspace && !this._roots.find(r => r.uri === valid.uri)) {\n            if (this._workspace.isDirectory) { // save the workspace data in a temporary file\n                const tempFile = await this.getTemporaryWorkspaceFile();\n                if (tempFile) {\n                    await this.save(tempFile);\n                }\n            }\n            this._workspace = await this.writeWorkspaceFile(this._workspace, [...this._roots, valid]);\n        }\n    }\n\n    /**\n     * Removes root folder(s) from workspace.\n     */\n    async removeRoots(uris: URI[]): Promise<void> {\n        if (!this.opened) {\n            throw new Error('Folder cannot be removed as there is no active folder in the current workspace.');\n        }\n        if (this._workspace) {\n            this._workspace = await this.writeWorkspaceFile(\n                this._workspace, this._roots.filter(root => uris.findIndex(u => u.toString() === root.uri) < 0)\n            );\n        }\n    }\n\n    private async writeWorkspaceFile(workspaceFile: FileStat | undefined, rootFolders: FileStat[]): Promise<FileStat | undefined> {\n        if (workspaceFile) {\n            const workspaceData = WorkspaceData.transformToRelative(\n                WorkspaceData.buildWorkspaceData(rootFolders.map(f => f.uri)), workspaceFile\n            );\n            if (workspaceData) {\n                const stat = await this.fileSystem.setContent(workspaceFile, JSON.stringify(workspaceData));\n                return stat;\n            }\n        }\n    }\n\n    private async getTemporaryWorkspaceFile(): Promise<FileStat | undefined> {\n        const home = await this.fileSystem.getCurrentUserHome();\n        if (home) {\n            const tempWorkspaceUri = getTemporaryWorkspaceFileUri(new URI(home.uri));\n            if (!await this.fileSystem.exists(tempWorkspaceUri.toString())) {\n                return this.fileSystem.createFile(tempWorkspaceUri.toString());\n            }\n            return this.toFileStat(tempWorkspaceUri);\n        }\n    }\n\n    /**\n     * Clears current workspace root.\n     */\n    async close(): Promise<void> {\n        this._workspace = undefined;\n        this._roots.length = 0;\n\n        await this.server.setMostRecentlyUsedWorkspace('');\n        this.reloadWindow();\n    }\n\n    /**\n     * returns a FileStat if the argument URI points to an existing directory. Otherwise, `undefined`.\n     */\n    protected async toValidRoot(uri: URI | string | undefined): Promise<FileStat | undefined> {\n        const fileStat = await this.toFileStat(uri);\n        if (fileStat && fileStat.isDirectory) {\n            return fileStat;\n        }\n        return undefined;\n    }\n\n    /**\n     * returns a FileStat if the argument URI points to a file or directory. Otherwise, `undefined`.\n     */\n    protected async toFileStat(uri: URI | string | undefined): Promise<FileStat | undefined> {\n        if (!uri) {\n            return undefined;\n        }\n        let uriStr = uri.toString();\n        try {\n            if (uriStr.endsWith('/')) {\n                uriStr = uriStr.slice(0, -1);\n            }\n            const fileStat = await this.fileSystem.getFileStat(uriStr);\n            if (!fileStat) {\n                return undefined;\n            }\n            return fileStat;\n        } catch (error) {\n            return undefined;\n        }\n    }\n\n    protected openWindow(uri: FileStat, options?: WorkspaceInput): void {\n        if (this.shouldPreserveWindow(options)) {\n            this.reloadWindow();\n        } else {\n            try {\n                this.openNewWindow();\n            } catch (error) {\n                // Fall back to reloading the current window in case the browser has blocked the new window\n                this._workspace = uri;\n                this.logger.error(error.toString()).then(() => this.reloadWindow());\n            }\n        }\n    }\n\n    protected reloadWindow(): void {\n        window.location.reload(true);\n    }\n\n    protected openNewWindow(): void {\n        this.windowService.openNewWindow(window.location.href);\n    }\n\n    protected shouldPreserveWindow(options?: WorkspaceInput): boolean {\n        return options !== undefined && !!options.preserveWindow;\n    }\n\n    /**\n     * Return true if one of the paths in paths array is present in the workspace\n     * NOTE: You should always explicitly use `/` as the separator between the path segments.\n     */\n    async containsSome(paths: string[]): Promise<boolean> {\n        await this.roots;\n        if (this.opened) {\n            for (const root of this._roots) {\n                const uri = new URI(root.uri);\n                for (const path of paths) {\n                    const fileUri = uri.resolve(path).toString();\n                    const exists = await this.fileSystem.exists(fileUri);\n                    if (exists) {\n                        return exists;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    get saved(): boolean {\n        return !!this._workspace && !this._workspace.isDirectory;\n    }\n\n    /**\n     * Save workspace data into a file\n     * @param uri URI or FileStat of the workspace file\n     */\n    async save(uri: URI | FileStat): Promise<void> {\n        const uriStr = uri instanceof URI ? uri.toString() : uri.uri;\n        if (!await this.fileSystem.exists(uriStr)) {\n            await this.fileSystem.createFile(uriStr);\n        }\n        let stat = await this.toFileStat(uriStr);\n        stat = await this.writeWorkspaceFile(stat, await this.roots);\n        await this.server.setMostRecentlyUsedWorkspace(uriStr);\n        await this.setWorkspace(stat);\n    }\n\n    protected readonly rootWatchers = new Map<string, Disposable>();\n\n    protected async watchRoots(): Promise<void> {\n        const rootUris = new Set(this._roots.map(r => r.uri));\n        for (const [uri, watcher] of this.rootWatchers.entries()) {\n            if (!rootUris.has(uri)) {\n                watcher.dispose();\n            }\n        }\n        for (const root of this._roots) {\n            this.watchRoot(root);\n        }\n    }\n\n    protected async watchRoot(root: FileStat): Promise<void> {\n        const uriStr = root.uri;\n        if (this.rootWatchers.has(uriStr)) {\n            return;\n        }\n        const watcher = this.watcher.watchFileChanges(new URI(uriStr));\n        this.rootWatchers.set(uriStr, Disposable.create(() => {\n            watcher.then(disposable => disposable.dispose());\n            this.rootWatchers.delete(uriStr);\n        }));\n    }\n\n}\n\nexport function getTemporaryWorkspaceFileUri(home: URI): URI {\n    return home.resolve('.theia').resolve(`Untitled.${THEIA_EXT}`).withScheme('file');\n}\n\nexport interface WorkspaceInput {\n\n    /**\n     * Tests whether the same window should be used or a new one has to be opened after setting the workspace root. By default it is `false`.\n     */\n    preserveWindow?: boolean;\n\n}\n\ninterface WorkspaceData {\n    folders: Array<{ path: string }>;\n    // TODO add workspace settings settings?: { [id: string]: any };\n}\n\nnamespace WorkspaceData {\n    const validateSchema = new Ajv().compile({\n        type: 'object',\n        properties: {\n            folders: {\n                description: 'Root folders in the workspace',\n                type: 'array',\n                items: {\n                    type: 'object',\n                    properties: {\n                        path: {\n                            type: 'string',\n                        }\n                    },\n                    required: ['path']\n                }\n            }\n        }\n    });\n\n    // tslint:disable-next-line:no-any\n    export function is(data: any): data is WorkspaceData {\n        return !!validateSchema(data);\n    }\n\n    export function buildWorkspaceData(folders: string[]): WorkspaceData {\n        return {\n            folders: folders.map(f => ({ path: f }))\n        };\n    }\n\n    export function transformToRelative(data: WorkspaceData, workspaceFile?: FileStat): WorkspaceData {\n        const folderUris: string[] = [];\n        const workspaceFileUri = new URI(workspaceFile ? workspaceFile.uri : '').withScheme('file');\n        for (const { path } of data.folders) {\n            const folderUri = new URI(path).withScheme('file');\n            const rel = workspaceFileUri.parent.relative(folderUri);\n            if (rel) {\n                folderUris.push(rel.toString());\n            } else {\n                folderUris.push(folderUri.toString());\n            }\n        }\n        return buildWorkspaceData(folderUris);\n    }\n\n    export function transformToAbsolute(data: WorkspaceData, workspaceFile?: FileStat): WorkspaceData {\n        if (workspaceFile) {\n            const folders: string[] = [];\n            for (const folder of data.folders) {\n                const path = folder.path;\n                if (path.startsWith('file:///')) {\n                    folders.push(path);\n                } else {\n                    folders.push(new URI(workspaceFile.uri).withScheme('file').parent.resolve(path).toString());\n                }\n\n            }\n            return Object.assign(data, buildWorkspaceData(folders));\n        }\n        return data;\n    }\n}\n","/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nexport * from './workspace-protocol';\n","/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nexport const workspacePath = '/services/workspace';\n\n/**\n * The JSON-RPC workspace interface.\n */\nexport const WorkspaceServer = Symbol('WorkspaceServer');\nexport interface WorkspaceServer {\n\n    /**\n     * Returns with a promise that resolves to the most recently used workspace folder URI as a string.\n     * Resolves to `undefined` if the workspace folder is not yet set.\n     */\n    getMostRecentlyUsedWorkspace(): Promise<string | undefined>;\n\n    /**\n     * Sets the desired string representation of the URI as the most recently used workspace folder.\n     */\n    setMostRecentlyUsedWorkspace(uri: string): Promise<void>;\n\n    /**\n     * Returns list of recently opened workspaces as an array.\n     */\n    getRecentWorkspaces(): Promise<string[]>\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { format, isEOL } from './format';\nimport { parseTree, findNodeAtLocation } from './parser';\nexport function removeProperty(text, path, formattingOptions) {\n    return setProperty(text, path, void 0, formattingOptions);\n}\nexport function setProperty(text, originalPath, value, formattingOptions, getInsertionIndex) {\n    var path = originalPath.slice();\n    var errors = [];\n    var root = parseTree(text, errors);\n    var parent = void 0;\n    var lastSegment = void 0;\n    while (path.length > 0) {\n        lastSegment = path.pop();\n        parent = findNodeAtLocation(root, path);\n        if (parent === void 0 && value !== void 0) {\n            if (typeof lastSegment === 'string') {\n                value = (_a = {}, _a[lastSegment] = value, _a);\n            }\n            else {\n                value = [value];\n            }\n        }\n        else {\n            break;\n        }\n    }\n    if (!parent) {\n        // empty document\n        if (value === void 0) { // delete\n            throw new Error('Can not delete in empty document');\n        }\n        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, formattingOptions);\n    }\n    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n        var existing = findNodeAtLocation(parent, [lastSegment]);\n        if (existing !== void 0) {\n            if (value === void 0) { // delete\n                if (!existing.parent) {\n                    throw new Error('Malformed AST');\n                }\n                var propertyIndex = parent.children.indexOf(existing.parent);\n                var removeBegin = void 0;\n                var removeEnd = existing.parent.offset + existing.parent.length;\n                if (propertyIndex > 0) {\n                    // remove the comma of the previous node\n                    var previous = parent.children[propertyIndex - 1];\n                    removeBegin = previous.offset + previous.length;\n                }\n                else {\n                    removeBegin = parent.offset + 1;\n                    if (parent.children.length > 1) {\n                        // remove the comma of the next node\n                        var next = parent.children[1];\n                        removeEnd = next.offset;\n                    }\n                }\n                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, formattingOptions);\n            }\n            else {\n                // set value of existing property\n                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, formattingOptions);\n            }\n        }\n        else {\n            if (value === void 0) { // delete\n                return []; // property does not exist, nothing to do\n            }\n            var newProperty = JSON.stringify(lastSegment) + \": \" + JSON.stringify(value);\n            var index = getInsertionIndex ? getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;\n            var edit = void 0;\n            if (index > 0) {\n                var previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            else if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };\n            }\n            return withFormatting(text, edit, formattingOptions);\n        }\n    }\n    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n        var insertIndex = lastSegment;\n        if (insertIndex === -1) {\n            // Insert\n            var newProperty = \"\" + JSON.stringify(value);\n            var edit = void 0;\n            if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                var previous = parent.children[parent.children.length - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, formattingOptions);\n        }\n        else {\n            if (value === void 0 && parent.children.length >= 0) {\n                //Removal\n                var removalIndex = lastSegment;\n                var toRemove = parent.children[removalIndex];\n                var edit = void 0;\n                if (parent.children.length === 1) {\n                    // only item\n                    edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };\n                }\n                else if (parent.children.length - 1 === removalIndex) {\n                    // last item\n                    var previous = parent.children[removalIndex - 1];\n                    var offset = previous.offset + previous.length;\n                    var parentEndOffset = parent.offset + parent.length;\n                    edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };\n                }\n                else {\n                    edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };\n                }\n                return withFormatting(text, edit, formattingOptions);\n            }\n            else {\n                throw new Error('Array modification not supported yet');\n            }\n        }\n    }\n    else {\n        throw new Error(\"Can not add \" + (typeof lastSegment !== 'number' ? 'index' : 'property') + \" to parent of type \" + parent.type);\n    }\n    var _a;\n}\nfunction withFormatting(text, edit, formattingOptions) {\n    // apply the edit\n    var newText = applyEdit(text, edit);\n    // format the new text\n    var begin = edit.offset;\n    var end = edit.offset + edit.content.length;\n    if (edit.length === 0 || edit.content.length === 0) { // insert or remove\n        while (begin > 0 && !isEOL(newText, begin - 1)) {\n            begin--;\n        }\n        while (end < newText.length && !isEOL(newText, end)) {\n            end++;\n        }\n    }\n    var edits = format(newText, { offset: begin, length: end - begin }, formattingOptions);\n    // apply the formatting edits and track the begin and end offsets of the changes\n    for (var i = edits.length - 1; i >= 0; i--) {\n        var edit_1 = edits[i];\n        newText = applyEdit(newText, edit_1);\n        begin = Math.min(begin, edit_1.offset);\n        end = Math.max(end, edit_1.offset + edit_1.length);\n        end += edit_1.content.length - edit_1.length;\n    }\n    // create a single edit with all changes\n    var editLength = text.length - (newText.length - end) - begin;\n    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];\n}\nexport function applyEdit(text, edit) {\n    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nexport function isWS(text, offset) {\n    return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}\n//# sourceMappingURL=edit.js.map","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner';\nexport function format(documentText, range, options) {\n    var initialIndentLevel;\n    var formatText;\n    var formatTextStart;\n    var rangeStart;\n    var rangeEnd;\n    if (range) {\n        rangeStart = range.offset;\n        rangeEnd = rangeStart + range.length;\n        formatTextStart = rangeStart;\n        while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\n            formatTextStart--;\n        }\n        var endOffset = rangeEnd;\n        while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\n            endOffset++;\n        }\n        formatText = documentText.substring(formatTextStart, endOffset);\n        initialIndentLevel = computeIndentLevel(formatText, options);\n    }\n    else {\n        formatText = documentText;\n        initialIndentLevel = 0;\n        formatTextStart = 0;\n        rangeStart = 0;\n        rangeEnd = documentText.length;\n    }\n    var eol = getEOL(options, documentText);\n    var lineBreak = false;\n    var indentLevel = 0;\n    var indentValue;\n    if (options.insertSpaces) {\n        indentValue = repeat(' ', options.tabSize || 4);\n    }\n    else {\n        indentValue = '\\t';\n    }\n    var scanner = createScanner(formatText, false);\n    var hasError = false;\n    function newLineAndIndent() {\n        return eol + repeat(indentValue, initialIndentLevel + indentLevel);\n    }\n    function scanNext() {\n        var token = scanner.scan();\n        lineBreak = false;\n        while (token === 15 /* Trivia */ || token === 14 /* LineBreakTrivia */) {\n            lineBreak = lineBreak || (token === 14 /* LineBreakTrivia */);\n            token = scanner.scan();\n        }\n        hasError = token === 16 /* Unknown */ || scanner.getTokenError() !== 0 /* None */;\n        return token;\n    }\n    var editOperations = [];\n    function addEdit(text, startOffset, endOffset) {\n        if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {\n            editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });\n        }\n    }\n    var firstToken = scanNext();\n    if (firstToken !== 17 /* EOF */) {\n        var firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n        var initialIndent = repeat(indentValue, initialIndentLevel);\n        addEdit(initialIndent, formatTextStart, firstTokenStart);\n    }\n    while (firstToken !== 17 /* EOF */) {\n        var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n        var secondToken = scanNext();\n        var replaceContent = '';\n        while (!lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {\n            // comments on the same line: keep them on the same line, but ignore them otherwise\n            var commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n            addEdit(' ', firstTokenEnd, commentTokenStart);\n            firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n            replaceContent = secondToken === 12 /* LineCommentTrivia */ ? newLineAndIndent() : '';\n            secondToken = scanNext();\n        }\n        if (secondToken === 2 /* CloseBraceToken */) {\n            if (firstToken !== 1 /* OpenBraceToken */) {\n                indentLevel--;\n                replaceContent = newLineAndIndent();\n            }\n        }\n        else if (secondToken === 4 /* CloseBracketToken */) {\n            if (firstToken !== 3 /* OpenBracketToken */) {\n                indentLevel--;\n                replaceContent = newLineAndIndent();\n            }\n        }\n        else {\n            switch (firstToken) {\n                case 3 /* OpenBracketToken */:\n                case 1 /* OpenBraceToken */:\n                    indentLevel++;\n                    replaceContent = newLineAndIndent();\n                    break;\n                case 5 /* CommaToken */:\n                case 12 /* LineCommentTrivia */:\n                    replaceContent = newLineAndIndent();\n                    break;\n                case 13 /* BlockCommentTrivia */:\n                    if (lineBreak) {\n                        replaceContent = newLineAndIndent();\n                    }\n                    else {\n                        // symbol following comment on the same line: keep on same line, separate with ' '\n                        replaceContent = ' ';\n                    }\n                    break;\n                case 6 /* ColonToken */:\n                    replaceContent = ' ';\n                    break;\n                case 10 /* StringLiteral */:\n                    if (secondToken === 6 /* ColonToken */) {\n                        replaceContent = '';\n                        break;\n                    }\n                // fall through\n                case 7 /* NullKeyword */:\n                case 8 /* TrueKeyword */:\n                case 9 /* FalseKeyword */:\n                case 11 /* NumericLiteral */:\n                case 2 /* CloseBraceToken */:\n                case 4 /* CloseBracketToken */:\n                    if (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */) {\n                        replaceContent = ' ';\n                    }\n                    else if (secondToken !== 5 /* CommaToken */ && secondToken !== 17 /* EOF */) {\n                        hasError = true;\n                    }\n                    break;\n                case 16 /* Unknown */:\n                    hasError = true;\n                    break;\n            }\n            if (lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {\n                replaceContent = newLineAndIndent();\n            }\n        }\n        var secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n        addEdit(replaceContent, firstTokenEnd, secondTokenStart);\n        firstToken = secondToken;\n    }\n    return editOperations;\n}\nfunction repeat(s, count) {\n    var result = '';\n    for (var i = 0; i < count; i++) {\n        result += s;\n    }\n    return result;\n}\nfunction computeIndentLevel(content, options) {\n    var i = 0;\n    var nChars = 0;\n    var tabSize = options.tabSize || 4;\n    while (i < content.length) {\n        var ch = content.charAt(i);\n        if (ch === ' ') {\n            nChars++;\n        }\n        else if (ch === '\\t') {\n            nChars += tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    return Math.floor(nChars / tabSize);\n}\nfunction getEOL(options, text) {\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charAt(i);\n        if (ch === '\\r') {\n            if (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                return '\\r\\n';\n            }\n            return '\\r';\n        }\n        else if (ch === '\\n') {\n            return '\\n';\n        }\n    }\n    return (options && options.eol) || '\\n';\n}\nexport function isEOL(text, offset) {\n    return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\n//# sourceMappingURL=format.js.map","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner';\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text, position) {\n    var segments = []; // strings or numbers\n    var earlyReturnException = new Object();\n    var previousNode = void 0;\n    var previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object',\n        parent: void 0\n    };\n    var isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.colonOffset = void 0;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = void 0;\n                isAtPropertyKey = position > offset;\n                segments.push(''); // push a placeholder (will be replaced)\n            },\n            onObjectProperty: function (name, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = void 0;\n                segments.pop();\n            },\n            onArrayBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = void 0;\n                segments.push(0);\n            },\n            onArrayEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = void 0;\n                segments.pop();\n            },\n            onLiteralValue: function (value, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getLiteralNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: function (sep, offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.colonOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = void 0;\n                }\n                else if (sep === ',') {\n                    var last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = void 0;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode: previousNode,\n        isAtPropertyKey: isAtPropertyKey,\n        matches: function (pattern) {\n            var k = 0;\n            for (var i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    var currentProperty = null;\n    var currentParent = [];\n    var previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    var visitor = {\n        onObjectBegin: function () {\n            var object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: function (name) {\n            currentProperty = name;\n        },\n        onObjectEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: function () {\n            var array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: void 0 }; // artificial root\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    var visitor = {\n        onObjectBegin: function (offset) {\n            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: function (name, offset, length) {\n            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });\n        },\n        onObjectEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: function (offset, length) {\n            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: function (value, offset, length) {\n            onValue({ type: getLiteralNodeType(value), offset: offset, length: length, parent: currentParent, value: value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: function (sep, offset, length) {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.colonOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    var result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root, path) {\n    if (!root) {\n        return void 0;\n    }\n    var node = root;\n    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n        var segment = path_1[_i];\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return void 0;\n            }\n            var found = false;\n            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n                var propertyNode = _b[_a];\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return void 0;\n            }\n        }\n        else {\n            var index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return void 0;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node) {\n    if (!node.parent || !node.parent.children) {\n        return [];\n    }\n    var path = getNodePath(node.parent);\n    if (node.parent.type === 'property') {\n        var key = node.parent.children[0].value;\n        path.push(key);\n    }\n    else if (node.parent.type === 'array') {\n        var index = node.parent.children.indexOf(node);\n        if (index !== -1) {\n            path.push(index);\n        }\n    }\n    return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node) {\n    switch (node.type) {\n        case 'array':\n            return node.children.map(getNodeValue);\n        case 'object':\n            var obj = Object.create(null);\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var prop = _a[_i];\n                var valueNode = prop.children[1];\n                if (valueNode) {\n                    obj[prop.children[0].value] = getNodeValue(valueNode);\n                }\n            }\n            return obj;\n        case 'null':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return node.value;\n        default:\n            return void 0;\n    }\n}\nexport function contains(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    if (contains(node, offset, includeRightBound)) {\n        var children = node.children;\n        if (Array.isArray(children)) {\n            for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n                var item = findNodeAtOffset(children[i], offset, includeRightBound);\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return node;\n    }\n    return void 0;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text, visitor, options) {\n    var _scanner = createScanner(text, false);\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };\n    }\n    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    var disallowComments = options && options.disallowComments;\n    var allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            var token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case 4 /* InvalidUnicode */:\n                    handleError(14 /* InvalidUnicode */);\n                    break;\n                case 5 /* InvalidEscapeCharacter */:\n                    handleError(15 /* InvalidEscapeCharacter */);\n                    break;\n                case 3 /* UnexpectedEndOfNumber */:\n                    handleError(13 /* UnexpectedEndOfNumber */);\n                    break;\n                case 1 /* UnexpectedEndOfComment */:\n                    if (!disallowComments) {\n                        handleError(11 /* UnexpectedEndOfComment */);\n                    }\n                    break;\n                case 2 /* UnexpectedEndOfString */:\n                    handleError(12 /* UnexpectedEndOfString */);\n                    break;\n                case 6 /* InvalidCharacter */:\n                    handleError(16 /* InvalidCharacter */);\n                    break;\n            }\n            switch (token) {\n                case 12 /* LineCommentTrivia */:\n                case 13 /* BlockCommentTrivia */:\n                    if (disallowComments) {\n                        handleError(10 /* InvalidCommentToken */);\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case 16 /* Unknown */:\n                    handleError(1 /* InvalidSymbol */);\n                    break;\n                case 15 /* Trivia */:\n                case 14 /* LineBreakTrivia */:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter, skipUntil) {\n        if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n        if (skipUntil === void 0) { skipUntil = []; }\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            var token = _scanner.getToken();\n            while (token !== 17 /* EOF */) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        var value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case 11 /* NumericLiteral */:\n                var value = 0;\n                try {\n                    value = JSON.parse(_scanner.getTokenValue());\n                    if (typeof value !== 'number') {\n                        handleError(2 /* InvalidNumberFormat */);\n                        value = 0;\n                    }\n                }\n                catch (e) {\n                    handleError(2 /* InvalidNumberFormat */);\n                }\n                onLiteralValue(value);\n                break;\n            case 7 /* NullKeyword */:\n                onLiteralValue(null);\n                break;\n            case 8 /* TrueKeyword */:\n                onLiteralValue(true);\n                break;\n            case 9 /* FalseKeyword */:\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== 10 /* StringLiteral */) {\n            handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === 6 /* ColonToken */) {\n            onSeparator(':');\n            scanNext(); // consume colon\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n        }\n        else {\n            handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n        }\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext(); // consume open brace\n        var needsComma = false;\n        while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseProperty()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== 2 /* CloseBraceToken */) {\n            handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);\n        }\n        else {\n            scanNext(); // consume close brace\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext(); // consume open bracket\n        var needsComma = false;\n        while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (_scanner.getToken() !== 4 /* CloseBracketToken */) {\n            handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);\n        }\n        else {\n            scanNext(); // consume close bracket\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case 3 /* OpenBracketToken */:\n                return parseArray();\n            case 1 /* OpenBraceToken */:\n                return parseObject();\n            case 10 /* StringLiteral */:\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === 17 /* EOF */) {\n        return true;\n    }\n    if (!parseValue()) {\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== 17 /* EOF */) {\n        handleError(9 /* EndOfFileExpected */, [], []);\n    }\n    return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text, replaceCh) {\n    var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\n    do {\n        pos = _scanner.getPosition();\n        kind = _scanner.scan();\n        switch (kind) {\n            case 12 /* LineCommentTrivia */:\n            case 13 /* BlockCommentTrivia */:\n            case 17 /* EOF */:\n                if (offset !== pos) {\n                    parts.push(text.substring(offset, pos));\n                }\n                if (replaceCh !== void 0) {\n                    parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                }\n                offset = _scanner.getPosition();\n                break;\n        }\n    } while (kind !== 17 /* EOF */);\n    return parts.join('');\n}\nfunction getLiteralNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        default: return 'null';\n    }\n}\n//# sourceMappingURL=parser.js.map","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport function createScanner(text, ignoreTrivia) {\n    if (ignoreTrivia === void 0) { ignoreTrivia = false; }\n    var pos = 0, len = text.length, value = '', tokenOffset = 0, token = 16 /* Unknown */, scanError = 0 /* None */;\n    function scanHexDigits(count, exact) {\n        var digits = 0;\n        var value = 0;\n        while (digits < count || !exact) {\n            var ch = text.charCodeAt(pos);\n            if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {\n                value = value * 16 + ch - 48 /* _0 */;\n            }\n            else if (ch >= 65 /* A */ && ch <= 70 /* F */) {\n                value = value * 16 + ch - 65 /* A */ + 10;\n            }\n            else if (ch >= 97 /* a */ && ch <= 102 /* f */) {\n                value = value * 16 + ch - 97 /* a */ + 10;\n            }\n            else {\n                break;\n            }\n            pos++;\n            digits++;\n        }\n        if (digits < count) {\n            value = -1;\n        }\n        return value;\n    }\n    function setPosition(newPosition) {\n        pos = newPosition;\n        value = '';\n        tokenOffset = 0;\n        token = 16 /* Unknown */;\n        scanError = 0 /* None */;\n    }\n    function scanNumber() {\n        var start = pos;\n        if (text.charCodeAt(pos) === 48 /* _0 */) {\n            pos++;\n        }\n        else {\n            pos++;\n            while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n            }\n        }\n        if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {\n            pos++;\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n            }\n            else {\n                scanError = 3 /* UnexpectedEndOfNumber */;\n                return text.substring(start, pos);\n            }\n        }\n        var end = pos;\n        if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {\n            pos++;\n            if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {\n                pos++;\n            }\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n                end = pos;\n            }\n            else {\n                scanError = 3 /* UnexpectedEndOfNumber */;\n            }\n        }\n        return text.substring(start, end);\n    }\n    function scanString() {\n        var result = '', start = pos;\n        while (true) {\n            if (pos >= len) {\n                result += text.substring(start, pos);\n                scanError = 2 /* UnexpectedEndOfString */;\n                break;\n            }\n            var ch = text.charCodeAt(pos);\n            if (ch === 34 /* doubleQuote */) {\n                result += text.substring(start, pos);\n                pos++;\n                break;\n            }\n            if (ch === 92 /* backslash */) {\n                result += text.substring(start, pos);\n                pos++;\n                if (pos >= len) {\n                    scanError = 2 /* UnexpectedEndOfString */;\n                    break;\n                }\n                ch = text.charCodeAt(pos++);\n                switch (ch) {\n                    case 34 /* doubleQuote */:\n                        result += '\\\"';\n                        break;\n                    case 92 /* backslash */:\n                        result += '\\\\';\n                        break;\n                    case 47 /* slash */:\n                        result += '/';\n                        break;\n                    case 98 /* b */:\n                        result += '\\b';\n                        break;\n                    case 102 /* f */:\n                        result += '\\f';\n                        break;\n                    case 110 /* n */:\n                        result += '\\n';\n                        break;\n                    case 114 /* r */:\n                        result += '\\r';\n                        break;\n                    case 116 /* t */:\n                        result += '\\t';\n                        break;\n                    case 117 /* u */:\n                        var ch_1 = scanHexDigits(4, true);\n                        if (ch_1 >= 0) {\n                            result += String.fromCharCode(ch_1);\n                        }\n                        else {\n                            scanError = 4 /* InvalidUnicode */;\n                        }\n                        break;\n                    default:\n                        scanError = 5 /* InvalidEscapeCharacter */;\n                }\n                start = pos;\n                continue;\n            }\n            if (ch >= 0 && ch <= 0x1f) {\n                if (isLineBreak(ch)) {\n                    result += text.substring(start, pos);\n                    scanError = 2 /* UnexpectedEndOfString */;\n                    break;\n                }\n                else {\n                    scanError = 6 /* InvalidCharacter */;\n                    // mark as error but continue with string\n                }\n            }\n            pos++;\n        }\n        return result;\n    }\n    function scanNext() {\n        value = '';\n        scanError = 0 /* None */;\n        tokenOffset = pos;\n        if (pos >= len) {\n            // at the end\n            tokenOffset = len;\n            return token = 17 /* EOF */;\n        }\n        var code = text.charCodeAt(pos);\n        // trivia: whitespace\n        if (isWhiteSpace(code)) {\n            do {\n                pos++;\n                value += String.fromCharCode(code);\n                code = text.charCodeAt(pos);\n            } while (isWhiteSpace(code));\n            return token = 15 /* Trivia */;\n        }\n        // trivia: newlines\n        if (isLineBreak(code)) {\n            pos++;\n            value += String.fromCharCode(code);\n            if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                pos++;\n                value += '\\n';\n            }\n            return token = 14 /* LineBreakTrivia */;\n        }\n        switch (code) {\n            // tokens: []{}:,\n            case 123 /* openBrace */:\n                pos++;\n                return token = 1 /* OpenBraceToken */;\n            case 125 /* closeBrace */:\n                pos++;\n                return token = 2 /* CloseBraceToken */;\n            case 91 /* openBracket */:\n                pos++;\n                return token = 3 /* OpenBracketToken */;\n            case 93 /* closeBracket */:\n                pos++;\n                return token = 4 /* CloseBracketToken */;\n            case 58 /* colon */:\n                pos++;\n                return token = 6 /* ColonToken */;\n            case 44 /* comma */:\n                pos++;\n                return token = 5 /* CommaToken */;\n            // strings\n            case 34 /* doubleQuote */:\n                pos++;\n                value = scanString();\n                return token = 10 /* StringLiteral */;\n            // comments\n            case 47 /* slash */:\n                var start = pos - 1;\n                // Single-line comment\n                if (text.charCodeAt(pos + 1) === 47 /* slash */) {\n                    pos += 2;\n                    while (pos < len) {\n                        if (isLineBreak(text.charCodeAt(pos))) {\n                            break;\n                        }\n                        pos++;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 12 /* LineCommentTrivia */;\n                }\n                // Multi-line comment\n                if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {\n                    pos += 2;\n                    var commentClosed = false;\n                    while (pos < len) {\n                        var ch = text.charCodeAt(pos);\n                        if (ch === 42 /* asterisk */ && (pos + 1 < len) && text.charCodeAt(pos + 1) === 47 /* slash */) {\n                            pos += 2;\n                            commentClosed = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    if (!commentClosed) {\n                        pos++;\n                        scanError = 1 /* UnexpectedEndOfComment */;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 13 /* BlockCommentTrivia */;\n                }\n                // just a single slash\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* Unknown */;\n            // numbers\n            case 45 /* minus */:\n                value += String.fromCharCode(code);\n                pos++;\n                if (pos === len || !isDigit(text.charCodeAt(pos))) {\n                    return token = 16 /* Unknown */;\n                }\n            // found a minus, followed by a number so\n            // we fall through to proceed with scanning\n            // numbers\n            case 48 /* _0 */:\n            case 49 /* _1 */:\n            case 50 /* _2 */:\n            case 51 /* _3 */:\n            case 52 /* _4 */:\n            case 53 /* _5 */:\n            case 54 /* _6 */:\n            case 55 /* _7 */:\n            case 56 /* _8 */:\n            case 57 /* _9 */:\n                value += scanNumber();\n                return token = 11 /* NumericLiteral */;\n            // literals and unknown symbols\n            default:\n                // is a literal? Read the full word.\n                while (pos < len && isUnknownContentCharacter(code)) {\n                    pos++;\n                    code = text.charCodeAt(pos);\n                }\n                if (tokenOffset !== pos) {\n                    value = text.substring(tokenOffset, pos);\n                    // keywords: true, false, null\n                    switch (value) {\n                        case 'true': return token = 8 /* TrueKeyword */;\n                        case 'false': return token = 9 /* FalseKeyword */;\n                        case 'null': return token = 7 /* NullKeyword */;\n                    }\n                    return token = 16 /* Unknown */;\n                }\n                // some\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* Unknown */;\n        }\n    }\n    function isUnknownContentCharacter(code) {\n        if (isWhiteSpace(code) || isLineBreak(code)) {\n            return false;\n        }\n        switch (code) {\n            case 125 /* closeBrace */:\n            case 93 /* closeBracket */:\n            case 123 /* openBrace */:\n            case 91 /* openBracket */:\n            case 34 /* doubleQuote */:\n            case 58 /* colon */:\n            case 44 /* comma */:\n            case 47 /* slash */:\n                return false;\n        }\n        return true;\n    }\n    function scanNextNonTrivia() {\n        var result;\n        do {\n            result = scanNext();\n        } while (result >= 12 /* LineCommentTrivia */ && result <= 15 /* Trivia */);\n        return result;\n    }\n    return {\n        setPosition: setPosition,\n        getPosition: function () { return pos; },\n        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n        getToken: function () { return token; },\n        getTokenValue: function () { return value; },\n        getTokenOffset: function () { return tokenOffset; },\n        getTokenLength: function () { return pos - tokenOffset; },\n        getTokenError: function () { return scanError; }\n    };\n}\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||\n        ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||\n        ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;\n}\nfunction isLineBreak(ch) {\n    return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;\n}\nfunction isDigit(ch) {\n    return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;\n}\n//# sourceMappingURL=scanner.js.map","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport * as formatter from './impl/format';\nimport * as edit from './impl/edit';\nimport * as scanner from './impl/scanner';\nimport * as parser from './impl/parser';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport var createScanner = scanner.createScanner;\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport var getLocation = parser.getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport var parse = parser.parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport var parseTree = parser.parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport var findNodeAtLocation = parser.findNodeAtLocation;\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport var findNodeAtOffset = parser.findNodeAtOffset;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport var getNodePath = parser.getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport var getNodeValue = parser.getNodeValue;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport var visit = parser.visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport var stripComments = parser.stripComments;\n/**\n * Computes the edits needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`\n */\nexport function format(documentText, range, options) {\n    return formatter.format(documentText, range, options);\n}\n/**\n * Computes the edits needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`\n */\nexport function modify(text, path, value, options) {\n    return edit.setProperty(text, path, value, options.formattingOptions, options.getInsertionIndex);\n}\n/**\n * Applies edits to a input string.\n */\nexport function applyEdits(text, edits) {\n    for (var i = edits.length - 1; i >= 0; i--) {\n        text = edit.applyEdit(text, edits[i]);\n    }\n    return text;\n}\n//# sourceMappingURL=main.js.map"],"sourceRoot":""}