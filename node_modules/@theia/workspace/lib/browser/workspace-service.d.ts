/********************************************************************************
 * Copyright (C) 2017 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import URI from '@theia/core/lib/common/uri';
import { FileSystem, FileStat } from '@theia/filesystem/lib/common';
import { FileSystemWatcher } from '@theia/filesystem/lib/browser/filesystem-watcher';
import { WorkspaceServer } from '../common';
import { WindowService } from '@theia/core/lib/browser/window/window-service';
import { FrontendApplication, FrontendApplicationContribution } from '@theia/core/lib/browser';
import { ILogger, Disposable, DisposableCollection, Emitter, Event } from '@theia/core';
import { WorkspacePreferences } from './workspace-preferences';
export declare const THEIA_EXT = "theia-workspace";
export declare const VSCODE_EXT = "code-workspace";
export declare const IWorkspaceService: unique symbol;
export interface IWorkspaceService {
    roots: Promise<FileStat[]>;
}
/**
 * The workspace service.
 */
export declare class WorkspaceService implements FrontendApplicationContribution {
    private _workspace;
    private _roots;
    private deferredRoots;
    private hasWorkspace;
    protected readonly fileSystem: FileSystem;
    protected readonly watcher: FileSystemWatcher;
    protected readonly server: WorkspaceServer;
    protected readonly windowService: WindowService;
    protected logger: ILogger;
    protected preferences: WorkspacePreferences;
    protected init(): Promise<void>;
    readonly roots: Promise<FileStat[]>;
    tryGetRoots(): FileStat[];
    readonly workspace: FileStat | undefined;
    protected readonly onWorkspaceChangeEmitter: Emitter<FileStat[]>;
    readonly onWorkspaceChanged: Event<FileStat[]>;
    protected readonly toDisposeOnWorkspace: DisposableCollection;
    protected setWorkspace(workspaceStat: FileStat | undefined): Promise<void>;
    protected updateWorkspace(): Promise<void>;
    protected updateRoots(): Promise<void>;
    protected computeRoots(): Promise<FileStat[]>;
    protected getWorkspaceDataFromFile(): Promise<WorkspaceData | undefined>;
    protected updateTitle(): void;
    /**
     * on unload, we set our workspace root as the last recently used on the backend.
     * @param app
     */
    onStop(app: FrontendApplication): void;
    onStart(): Promise<void>;
    readonly hasHistory: boolean;
    recentWorkspaces(): Promise<string[]>;
    /**
     * Returns `true` if current workspace root is set.
     * @returns {boolean}
     */
    readonly opened: boolean;
    /**
     * Returns `true` if there is an opened workspace in theia, and the workspace has more than one root.
     * @returns {boolean}
     */
    readonly isMultiRootWorkspaceOpened: boolean;
    /**
     * Opens directory, or recreates a workspace from the file that `uri` points to.
     */
    open(uri: URI, options?: WorkspaceInput): void;
    protected doOpen(uri: URI, options?: WorkspaceInput): Promise<void>;
    /**
     * Adds a root folder to the workspace
     * @param uri URI of the root folder being added
     */
    addRoot(uri: URI): Promise<void>;
    /**
     * Removes root folder(s) from workspace.
     */
    removeRoots(uris: URI[]): Promise<void>;
    private writeWorkspaceFile;
    private getTemporaryWorkspaceFile;
    /**
     * Clears current workspace root.
     */
    close(): Promise<void>;
    /**
     * returns a FileStat if the argument URI points to an existing directory. Otherwise, `undefined`.
     */
    protected toValidRoot(uri: URI | string | undefined): Promise<FileStat | undefined>;
    /**
     * returns a FileStat if the argument URI points to a file or directory. Otherwise, `undefined`.
     */
    protected toFileStat(uri: URI | string | undefined): Promise<FileStat | undefined>;
    protected openWindow(uri: FileStat, options?: WorkspaceInput): void;
    protected reloadWindow(): void;
    protected openNewWindow(): void;
    protected shouldPreserveWindow(options?: WorkspaceInput): boolean;
    /**
     * Return true if one of the paths in paths array is present in the workspace
     * NOTE: You should always explicitly use `/` as the separator between the path segments.
     */
    containsSome(paths: string[]): Promise<boolean>;
    readonly saved: boolean;
    /**
     * Save workspace data into a file
     * @param uri URI or FileStat of the workspace file
     */
    save(uri: URI | FileStat): Promise<void>;
    protected readonly rootWatchers: Map<string, Disposable>;
    protected watchRoots(): Promise<void>;
    protected watchRoot(root: FileStat): Promise<void>;
}
export declare function getTemporaryWorkspaceFileUri(home: URI): URI;
export interface WorkspaceInput {
    /**
     * Tests whether the same window should be used or a new one has to be opened after setting the workspace root. By default it is `false`.
     */
    preserveWindow?: boolean;
}
interface WorkspaceData {
    folders: Array<{
        path: string;
    }>;
}
declare namespace WorkspaceData {
    const validateSchema = new Ajv().compile({
        type: 'object',
        properties: {
            folders: {
                description: 'Root folders in the workspace',
                type: 'array',
                items: {
                    type: 'object',
                    properties: {
                        path: {
                            type: 'string',
                        }
                    },
                    required: ['path']
                }
            }
        }
    });
    export function is(data: any): data is WorkspaceData {
        return !!validateSchema(data);
    }
    export function buildWorkspaceData(folders: string[]): WorkspaceData {
        return {
            folders: folders.map(f => ({ path: f }))
        };
    }
    export function transformToRelative(data: WorkspaceData, workspaceFile?: FileStat): WorkspaceData {
        const folderUris: string[] = [];
        const workspaceFileUri = new URI(workspaceFile ? workspaceFile.uri : '').withScheme('file');
        for (const { path } of data.folders) {
            const folderUri = new URI(path).withScheme('file');
            const rel = workspaceFileUri.parent.relative(folderUri);
            if (rel) {
                folderUris.push(rel.toString());
            }
            else {
                folderUris.push(folderUri.toString());
            }
        }
        return buildWorkspaceData(folderUris);
    }
    export function transformToAbsolute(data: WorkspaceData, workspaceFile?: FileStat): WorkspaceData {
        if (workspaceFile) {
            const folders: string[] = [];
            for (const folder of data.folders) {
                const path = folder.path;
                if (path.startsWith('file:///')) {
                    folders.push(path);
                }
                else {
                    folders.push(new URI(workspaceFile.uri).withScheme('file').parent.resolve(path).toString());
                }
            }
            return Object.assign(data, buildWorkspaceData(folders));
        }
        return data;
    }
}
export {};
//# sourceMappingURL=workspace-service.d.ts.map