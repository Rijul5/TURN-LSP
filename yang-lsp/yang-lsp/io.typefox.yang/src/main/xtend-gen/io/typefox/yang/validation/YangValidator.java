/**
 * generated by Xtext 2.13.0-SNAPSHOT
 */
package io.typefox.yang.validation;

import com.google.common.base.CharMatcher;
import com.google.common.base.Objects;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Multimap;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import io.typefox.yang.utils.IterableExtensions2;
import io.typefox.yang.utils.YangDateUtils;
import io.typefox.yang.utils.YangExtensions;
import io.typefox.yang.utils.YangNameUtils;
import io.typefox.yang.utils.YangRefinable;
import io.typefox.yang.utils.YangTypesExtensions;
import io.typefox.yang.validation.AbstractYangValidator;
import io.typefox.yang.validation.IssueCodes;
import io.typefox.yang.validation.SubstatementGroup;
import io.typefox.yang.validation.SubstatementRuleProvider;
import io.typefox.yang.validation.YangEnumerableValidator;
import io.typefox.yang.yang.AbstractModule;
import io.typefox.yang.yang.Action;
import io.typefox.yang.yang.Anydata;
import io.typefox.yang.yang.Anyxml;
import io.typefox.yang.yang.Augment;
import io.typefox.yang.yang.Base;
import io.typefox.yang.yang.BelongsTo;
import io.typefox.yang.yang.Choice;
import io.typefox.yang.yang.Default;
import io.typefox.yang.yang.Deviate;
import io.typefox.yang.yang.FractionDigits;
import io.typefox.yang.yang.Identity;
import io.typefox.yang.yang.IfFeature;
import io.typefox.yang.yang.Import;
import io.typefox.yang.yang.Include;
import io.typefox.yang.yang.Key;
import io.typefox.yang.yang.KeyReference;
import io.typefox.yang.yang.Leaf;
import io.typefox.yang.yang.LeafList;
import io.typefox.yang.yang.Mandatory;
import io.typefox.yang.yang.MaxElements;
import io.typefox.yang.yang.MinElements;
import io.typefox.yang.yang.Modifier;
import io.typefox.yang.yang.Notification;
import io.typefox.yang.yang.OrderedBy;
import io.typefox.yang.yang.Pattern;
import io.typefox.yang.yang.Presence;
import io.typefox.yang.yang.Refinable;
import io.typefox.yang.yang.Revision;
import io.typefox.yang.yang.Rpc;
import io.typefox.yang.yang.SchemaNode;
import io.typefox.yang.yang.SchemaNodeIdentifier;
import io.typefox.yang.yang.Statement;
import io.typefox.yang.yang.Status;
import io.typefox.yang.yang.Submodule;
import io.typefox.yang.yang.Type;
import io.typefox.yang.yang.Typedef;
import io.typefox.yang.yang.YangPackage;
import io.typefox.yang.yang.YangVersion;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import org.apache.xerces.impl.xpath.regex.ParseException;
import org.apache.xerces.impl.xpath.regex.RegularExpression;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.ILeafNode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.IScopeProvider;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.StringExtensions;

/**
 * This class contains custom validation rules for the YANG language.
 */
@Singleton
@SuppressWarnings("all")
public class YangValidator extends AbstractYangValidator {
  @Inject
  @Extension
  private YangExtensions _yangExtensions;
  
  @Inject
  @Extension
  private YangTypesExtensions _yangTypesExtensions;
  
  @Inject
  @Extension
  private YangEnumerableValidator _yangEnumerableValidator;
  
  @Inject
  private IQualifiedNameProvider qualifiedNameProvider;
  
  @Inject
  private IScopeProvider scopeProvider;
  
  @Inject
  private SubstatementRuleProvider substatementRuleProvider;
  
  private final Multimap<EClass, EClass> validAugmentStatements;
  
  private final Collection<EClass> validShorthandStatements;
  
  public YangValidator() {
    super();
    this.validAugmentStatements = LinkedHashMultimap.<EClass, EClass>create();
    final Consumer<EClass> _function = (EClass it) -> {
      this.validAugmentStatements.putAll(it, Collections.<EClass>unmodifiableList(CollectionLiterals.<EClass>newArrayList(YangPackage.Literals.CONTAINER, YangPackage.Literals.LEAF, YangPackage.Literals.LIST, YangPackage.Literals.LEAF_LIST, YangPackage.Literals.USES, YangPackage.Literals.CHOICE)));
      if (((it == YangPackage.Literals.CONTAINER) || (it == YangPackage.Literals.LIST))) {
        this.validAugmentStatements.putAll(it, Collections.<EClass>unmodifiableList(CollectionLiterals.<EClass>newArrayList(YangPackage.Literals.ACTION, YangPackage.Literals.NOTIFICATION)));
      }
    };
    Collections.<EClass>unmodifiableList(CollectionLiterals.<EClass>newArrayList(YangPackage.Literals.CONTAINER, YangPackage.Literals.LIST, YangPackage.Literals.CASE, YangPackage.Literals.INPUT, YangPackage.Literals.OUTPUT, YangPackage.Literals.NOTIFICATION)).forEach(_function);
    this.validAugmentStatements.put(YangPackage.Literals.CHOICE, YangPackage.Literals.CASE);
    this.validShorthandStatements = ImmutableList.<EClass>copyOf(new EClass[] { YangPackage.Literals.ANYDATA, YangPackage.Literals.ANYXML, YangPackage.Literals.CHOICE, YangPackage.Literals.CONTAINER, YangPackage.Literals.LEAF, YangPackage.Literals.LIST, YangPackage.Literals.LEAF_LIST });
  }
  
  @Check
  public void checkVersion(final YangVersion it) {
    if (((!Objects.equal(it.getYangVersion(), YangExtensions.YANG_1)) && (!Objects.equal(it.getYangVersion(), YangExtensions.YANG_1_1)))) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("The version must be either \"");
      _builder.append(YangExtensions.YANG_1);
      _builder.append("\" or \"");
      _builder.append(YangExtensions.YANG_1_1);
      _builder.append("\".");
      final String message = _builder.toString();
      this.error(message, it, YangPackage.Literals.YANG_VERSION__YANG_VERSION, IssueCodes.INCORRECT_VERSION);
    }
  }
  
  @Check
  public void checkVersionConsistency(final AbstractModule baseModule) {
    final String baseModuleVersion = this._yangExtensions.getYangVersion(baseModule);
    final Function1<Include, Boolean> _function = (Include it) -> {
      boolean _and = false;
      AbstractModule _module = it.getModule();
      Resource _eResource = null;
      if (_module!=null) {
        _eResource=_module.eResource();
      }
      boolean _tripleNotEquals = (_eResource != null);
      if (!_tripleNotEquals) {
        _and = false;
      } else {
        boolean _eIsProxy = it.getModule().eIsProxy();
        boolean _not = (!_eIsProxy);
        _and = _not;
      }
      return Boolean.valueOf(_and);
    };
    final Consumer<Include> _function_1 = (Include submoduleStatement) -> {
      final String submoduleVersion = this._yangExtensions.getYangVersion(submoduleStatement.getModule());
      boolean _notEquals = (!Objects.equal(submoduleVersion, baseModuleVersion));
      if (_notEquals) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Cannot include a version ");
        _builder.append(submoduleVersion);
        _builder.append(" submodule in a version ");
        _builder.append(baseModuleVersion);
        _builder.append(" module.");
        final String message = _builder.toString();
        this.error(message, submoduleStatement, YangPackage.Literals.ABSTRACT_IMPORT__MODULE, IssueCodes.BAD_INCLUDE_YANG_VERSION);
      }
    };
    IterableExtensions.filter(this._yangExtensions.<Include>substatementsOfType(baseModule, Include.class), _function).forEach(_function_1);
    boolean _equals = Objects.equal(baseModuleVersion, YangExtensions.YANG_1);
    if (_equals) {
      final Function1<Import, Boolean> _function_2 = (Import it) -> {
        boolean _and = false;
        AbstractModule _module = it.getModule();
        Resource _eResource = null;
        if (_module!=null) {
          _eResource=_module.eResource();
        }
        boolean _tripleNotEquals = (_eResource != null);
        if (!_tripleNotEquals) {
          _and = false;
        } else {
          boolean _eIsProxy = it.getModule().eIsProxy();
          boolean _not = (!_eIsProxy);
          _and = _not;
        }
        return Boolean.valueOf(_and);
      };
      final Consumer<Import> _function_3 = (Import importStatement) -> {
        final String importedModuleVersion = this._yangExtensions.getYangVersion(importStatement.getModule());
        boolean _notEquals = (!Objects.equal(baseModuleVersion, importedModuleVersion));
        if (_notEquals) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("Cannot import a version ");
          _builder.append(importedModuleVersion);
          _builder.append(" module in a version ");
          _builder.append(baseModuleVersion);
          _builder.append(" module.");
          final String message = _builder.toString();
          this.error(message, importStatement, YangPackage.Literals.ABSTRACT_IMPORT__MODULE, IssueCodes.BAD_IMPORT_YANG_VERSION);
        }
      };
      IterableExtensions.filter(this._yangExtensions.<Import>substatementsOfType(baseModule, Import.class), _function_2).forEach(_function_3);
    }
  }
  
  @Check
  public void checkVersionConsistency(final Submodule subModule) {
    final String submoduleVersion = this._yangExtensions.getYangVersion(subModule);
    final Function1<BelongsTo, Boolean> _function = (BelongsTo it) -> {
      boolean _and = false;
      io.typefox.yang.yang.Module _module = it.getModule();
      Resource _eResource = null;
      if (_module!=null) {
        _eResource=_module.eResource();
      }
      boolean _tripleNotEquals = (_eResource != null);
      if (!_tripleNotEquals) {
        _and = false;
      } else {
        boolean _eIsProxy = it.getModule().eIsProxy();
        boolean _not = (!_eIsProxy);
        _and = _not;
      }
      return Boolean.valueOf(_and);
    };
    final Consumer<BelongsTo> _function_1 = (BelongsTo belongsTo) -> {
      final String baseModuleVersion = this._yangExtensions.getYangVersion(belongsTo.getModule());
      boolean _notEquals = (!Objects.equal(submoduleVersion, baseModuleVersion));
      if (_notEquals) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("A version ");
        _builder.append(submoduleVersion);
        _builder.append(" submodule cannot be included in a version ");
        _builder.append(baseModuleVersion);
        _builder.append(" module.");
        final String message = _builder.toString();
        this.error(message, belongsTo, YangPackage.Literals.BELONGS_TO__MODULE, IssueCodes.BAD_INCLUDE_YANG_VERSION);
      }
    };
    IterableExtensions.filter(this._yangExtensions.<BelongsTo>substatementsOfType(subModule, BelongsTo.class), _function).forEach(_function_1);
  }
  
  @Check
  public void checkSubstatements(final Statement it) {
    SubstatementGroup _get = this.substatementRuleProvider.get(it.eClass());
    if (_get!=null) {
      _get.checkSubstatements(it, this);
    }
  }
  
  @Check
  public void checkTypeRestriction(final Type it) {
    final Iterable<? extends Refinable> refinements = this._yangExtensions.<Refinable>substatementsOfType(it, Refinable.class);
    boolean _isNullOrEmpty = IterableExtensions.isNullOrEmpty(refinements);
    boolean _not = (!_isNullOrEmpty);
    if (_not) {
      final Class<? extends Refinable> expectedRefinementKind = this._yangTypesExtensions.getRefinementKind(it);
      final Consumer<Refinable> _function = (Refinable it_1) -> {
        if (((expectedRefinementKind == null) || (!expectedRefinementKind.isAssignableFrom(it_1.getClass())))) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("Type cannot have \"");
          String _yangName = YangNameUtils.getYangName(it_1.eClass());
          _builder.append(_yangName);
          _builder.append("\" restriction statement.");
          final String message = _builder.toString();
          this.error(message, it_1, YangPackage.Literals.REFINABLE__EXPRESSION, IssueCodes.TYPE_ERROR);
        }
      };
      refinements.forEach(_function);
    }
  }
  
  @Check
  public boolean checkRefinement(final Refinable it) {
    boolean _xblockexpression = false;
    {
      final YangRefinable yangRefinable = this._yangTypesExtensions.getYangRefinable(it);
      boolean _xifexpression = false;
      if ((yangRefinable != null)) {
        _xifexpression = yangRefinable.validate(this);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  @Check
  public void checkUnionType(final Type it) {
    boolean _isUnion = this._yangTypesExtensions.isUnion(it);
    if (_isUnion) {
      boolean _isNullOrEmpty = IterableExtensions.isNullOrEmpty(this._yangExtensions.<Type>substatementsOfType(it, Type.class));
      if (_isNullOrEmpty) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Type substatement must be present for each union type.");
        final String message = _builder.toString();
        this.error(message, it, YangPackage.Literals.TYPE__TYPE_REF, IssueCodes.TYPE_ERROR);
      }
    }
  }
  
  @Check
  public void checkIdentityrefType(final Type it) {
    boolean _isIdentityref = this._yangTypesExtensions.isIdentityref(it);
    if (_isIdentityref) {
      boolean _isNullOrEmpty = IterableExtensions.isNullOrEmpty(this._yangExtensions.<Base>substatementsOfType(it, Base.class));
      if (_isNullOrEmpty) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("The \"base\" statement must be present at least once for all \"identityref\" types");
        final String message = _builder.toString();
        this.error(message, it, YangPackage.Literals.TYPE__TYPE_REF, IssueCodes.TYPE_ERROR);
      }
    }
  }
  
  @Check
  public void checkEnumerables(final Type it) {
    this._yangEnumerableValidator.validateEnumerable(it, this);
  }
  
  @Check
  public void checkEnumeration(final Type type) {
    final Iterable<? extends io.typefox.yang.yang.Enum> enums = this._yangExtensions.<io.typefox.yang.yang.Enum>substatementsOfType(type, io.typefox.yang.yang.Enum.class);
    boolean _isSubtypeOfEnumeration = this._yangTypesExtensions.isSubtypeOfEnumeration(type);
    boolean _not = (!_isSubtypeOfEnumeration);
    if (_not) {
      final Consumer<io.typefox.yang.yang.Enum> _function = (io.typefox.yang.yang.Enum it) -> {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Only enumeration types can have a \"enum\" statement.");
        final String message = _builder.toString();
        this.error(message, type, YangPackage.Literals.TYPE__TYPE_REF, IssueCodes.TYPE_ERROR);
      };
      enums.forEach(_function);
    } else {
      final Consumer<io.typefox.yang.yang.Enum> _function_1 = (io.typefox.yang.yang.Enum it) -> {
        String _xifexpression = null;
        int _length = it.getName().length();
        boolean _tripleEquals = (_length == 0);
        if (_tripleEquals) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("The name must not be zero-length.");
          _xifexpression = _builder.toString();
        } else {
          String _xifexpression_1 = null;
          String _name = it.getName();
          String _trimFrom = CharMatcher.whitespace().or(CharMatcher.breakingWhitespace()).trimFrom(it.getName());
          boolean _notEquals = (!Objects.equal(_name, _trimFrom));
          if (_notEquals) {
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("The name must not have any leading or trailing whitespace characters.");
            _xifexpression_1 = _builder_1.toString();
          } else {
            _xifexpression_1 = null;
          }
          _xifexpression = _xifexpression_1;
        }
        final String message = _xifexpression;
        if ((message != null)) {
          this.error(message, it, YangPackage.Literals.ENUMERABLE__NAME, IssueCodes.TYPE_ERROR);
        }
      };
      enums.forEach(_function_1);
    }
  }
  
  @Check
  public void checkFractionDigitsExist(final Type it) {
    final FractionDigits fractionDigits = this._yangExtensions.<FractionDigits>firstSubstatementsOfType(it, FractionDigits.class);
    final boolean fractionDigitsExist = (fractionDigits != null);
    final boolean decimalBuiltin = this._yangTypesExtensions.isDecimal(it);
    if (decimalBuiltin) {
      if (fractionDigitsExist) {
        final int value = this._yangTypesExtensions.getFractionDigitsAsInt(it);
        if (((Integer.valueOf(value).intValue() < 1) || (Integer.valueOf(value).intValue() > 18))) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("The \"fraction-digits\" value must be an integer between 1 and 18, inclusively.");
          final String message = _builder.toString();
          this.error(message, fractionDigits, YangPackage.Literals.FRACTION_DIGITS__RANGE, IssueCodes.TYPE_ERROR);
        }
      } else {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("The \"fraction-digits\" statement must be present for \"decimal64\" types.");
        final String message_1 = _builder_1.toString();
        this.error(message_1, it, YangPackage.Literals.TYPE__TYPE_REF, IssueCodes.TYPE_ERROR);
      }
    } else {
      if (fractionDigitsExist) {
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("Only decimal64 types can have a \"fraction-digits\" statement.");
        final String message_2 = _builder_2.toString();
        this.error(message_2, it, YangPackage.Literals.TYPE__TYPE_REF, IssueCodes.TYPE_ERROR);
      }
    }
  }
  
  @Check
  public RegularExpression checkPattern(final Pattern it) {
    RegularExpression _xifexpression = null;
    EObject _eContainer = it.eContainer();
    if ((_eContainer instanceof Type)) {
      RegularExpression _xblockexpression = null;
      {
        EObject _eContainer_1 = it.eContainer();
        final Type type = ((Type) _eContainer_1);
        RegularExpression _xifexpression_1 = null;
        boolean _isSubtypeOfString = this._yangTypesExtensions.isSubtypeOfString(type);
        if (_isSubtypeOfString) {
          RegularExpression _xtrycatchfinallyexpression = null;
          try {
            String _nullToEmpty = Strings.nullToEmpty(it.getRegexp());
            _xtrycatchfinallyexpression = new RegularExpression(_nullToEmpty, "X");
          } catch (final Throwable _t) {
            if (_t instanceof ParseException) {
              String _xifexpression_2 = null;
              boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(it.getRegexp());
              if (_isNullOrEmpty) {
                _xifexpression_2 = "Regular expression must be specified.";
              } else {
                StringConcatenation _builder = new StringConcatenation();
                _builder.append("Invalid regular expression pattern: \"");
                String _regexp = it.getRegexp();
                _builder.append(_regexp);
                _builder.append("\".");
                _xifexpression_2 = _builder.toString();
              }
              final String message = _xifexpression_2;
              this.error(message, it, YangPackage.Literals.PATTERN__REGEXP, IssueCodes.TYPE_ERROR);
            } else {
              throw Exceptions.sneakyThrow(_t);
            }
          }
          _xifexpression_1 = _xtrycatchfinallyexpression;
        } else {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("Only string types can have a \"pattern\" statement.");
          final String message_1 = _builder_1.toString();
          this.error(message_1, type, YangPackage.Literals.TYPE__TYPE_REF, IssueCodes.TYPE_ERROR);
        }
        _xblockexpression = _xifexpression_1;
      }
      _xifexpression = _xblockexpression;
    }
    return _xifexpression;
  }
  
  @Check
  public void checkModifier(final Modifier it) {
    String _modifier = it.getModifier();
    boolean _notEquals = (!Objects.equal(_modifier, "invert-match"));
    if (_notEquals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Modifier value must be \"invert-match\".");
      final String message = _builder.toString();
      this.error(message, it, YangPackage.Literals.MODIFIER__MODIFIER, IssueCodes.TYPE_ERROR);
    }
  }
  
  @Check
  public Date checkRevisionFormat(final Revision it) {
    Date _xifexpression = null;
    String _revision = it.getRevision();
    boolean _tripleNotEquals = (_revision != null);
    if (_tripleNotEquals) {
      Date _xtrycatchfinallyexpression = null;
      try {
        _xtrycatchfinallyexpression = YangDateUtils.getRevisionDateFormat().parse(it.getRevision());
      } catch (final Throwable _t) {
        if (_t instanceof java.text.ParseException) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("The revision date string should be in the following format: \"YYYY-MM-DD\".");
          final String message = _builder.toString();
          this.warning(message, it, YangPackage.Literals.REVISION__REVISION, IssueCodes.INVALID_REVISION_FORMAT);
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
      _xifexpression = _xtrycatchfinallyexpression;
    }
    return _xifexpression;
  }
  
  @Check
  public void checkRevisionOrder(final AbstractModule it) {
    final List<? extends Revision> revisions = IterableExtensions.toList(this._yangExtensions.<Revision>substatementsOfType(it, Revision.class));
    int _size = revisions.size();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(1, _size, true);
    for (final Integer index : _doubleDotLessThan) {
      {
        final Revision previous = revisions.get(((index).intValue() - 1));
        final Revision current = revisions.get((index).intValue());
        boolean _isGreaterThan = YangDateUtils.isGreaterThan(current, previous);
        if (_isGreaterThan) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("The revision statement is not given in reverse chronological order.");
          final String message = _builder.toString();
          this.warning(message, current, YangPackage.Literals.REVISION__REVISION, IssueCodes.REVISION_ORDER);
        }
      }
    }
  }
  
  @Check
  public void checkRevisionInFileName(final AbstractModule it) {
    final String revisionFile = this._yangExtensions.getRevisionFromFileName(it);
    if ((revisionFile != null)) {
      try {
        YangDateUtils.getRevisionDateFormat().parse(revisionFile);
        final Revision revisionStatement = IterableExtensions.head(this._yangExtensions.<Revision>substatementsOfType(it, Revision.class));
        if ((((revisionStatement != null) && (revisionStatement.getRevision() != null)) && (!Objects.equal(revisionStatement.getRevision(), revisionFile)))) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("The revision date in the file name does not match.");
          final String message = _builder.toString();
          this.warning(message, revisionStatement, YangPackage.Literals.REVISION__REVISION, IssueCodes.REVISION_MISMATCH);
        }
      } catch (final Throwable _t) {
        if (_t instanceof java.text.ParseException) {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("The revision date in the file name should be in the following format: \"YYYY-MM-DD\".");
          final String message_1 = _builder_1.toString();
          this.warning(message_1, it, YangPackage.Literals.ABSTRACT_MODULE__NAME, IssueCodes.INVALID_REVISION_FORMAT);
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
    }
  }
  
  @Check
  public void checkTypedef(final Typedef it) {
    boolean _isBuiltinName = this._yangTypesExtensions.isBuiltinName(it.getName());
    if (_isBuiltinName) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Illegal type name \"");
      String _name = it.getName();
      _builder.append(_name);
      _builder.append("\".");
      final String message = _builder.toString();
      this.error(message, it, YangPackage.Literals.SCHEMA_NODE__NAME, IssueCodes.BAD_TYPE_NAME);
    }
  }
  
  @Check
  public void checkMandatoryValue(final Mandatory it) {
    String _isMandatory = it.getIsMandatory();
    boolean _tripleNotEquals = (_isMandatory != null);
    if (_tripleNotEquals) {
      final Set<String> validValues = Collections.<String>unmodifiableSet(CollectionLiterals.<String>newHashSet("true", "false"));
      boolean _contains = validValues.contains(it.getIsMandatory());
      boolean _not = (!_contains);
      if (_not) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("The argument of the \"mandatory\" statement must be either \"true\" or \"false\".");
        final String message = _builder.toString();
        this.error(message, it, YangPackage.Literals.MANDATORY__IS_MANDATORY, IssueCodes.TYPE_ERROR);
      }
    }
  }
  
  @Check
  public void checkMinElements(final MinElements it) {
    final Integer expectedElements = this.getParseIntSafe(it.getMinElements());
    if (((expectedElements == null) || (expectedElements.intValue() < 0))) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("The value of the \"min-elements\" must be a non-negative integer.");
      final String message = _builder.toString();
      this.error(message, it, YangPackage.Literals.MIN_ELEMENTS__MIN_ELEMENTS, IssueCodes.TYPE_ERROR);
    }
  }
  
  @Check
  public void chechMaxElements(final MaxElements it) {
    String _maxElements = it.getMaxElements();
    boolean _notEquals = (!Objects.equal(_maxElements, "unbounded"));
    if (_notEquals) {
      final Integer expectedElements = this.getParseIntSafe(it.getMaxElements());
      if (((expectedElements == null) || (expectedElements.intValue() < 1))) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("The value of the \"max-elements\" must be a positive integer or the string \"unbounded\".");
        final String message = _builder.toString();
        this.error(message, it, YangPackage.Literals.MIN_ELEMENTS__MIN_ELEMENTS, IssueCodes.TYPE_ERROR);
      }
    }
  }
  
  @Check
  public void checkOrderedBy(final OrderedBy it) {
    String _orderedBy = it.getOrderedBy();
    boolean _tripleNotEquals = (_orderedBy != null);
    if (_tripleNotEquals) {
      final Set<String> validValues = Collections.<String>unmodifiableSet(CollectionLiterals.<String>newHashSet("system", "user"));
      boolean _contains = validValues.contains(it.getOrderedBy());
      boolean _not = (!_contains);
      if (_not) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("The argument of the \"ordered-by\" statement must be either \"system\" or \"user\".");
        final String message = _builder.toString();
        this.error(message, it, YangPackage.Literals.ORDERED_BY__ORDERED_BY, IssueCodes.TYPE_ERROR);
      }
    }
  }
  
  @Check
  public void checkKey(final Key key) {
    final Function1<KeyReference, Boolean> _function = (KeyReference it) -> {
      Leaf _node = it.getNode();
      String _name = null;
      if (_node!=null) {
        _name=_node.getName();
      }
      boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(_name);
      return Boolean.valueOf((!_isNullOrEmpty));
    };
    final Function1<KeyReference, String> _function_1 = (KeyReference it) -> {
      return it.getNode().getName();
    };
    final BiConsumer<String, Collection<KeyReference>> _function_2 = (String name, Collection<KeyReference> nodesWithSameName) -> {
      int _size = nodesWithSameName.size();
      boolean _greaterThan = (_size > 1);
      if (_greaterThan) {
        final Consumer<KeyReference> _function_3 = (KeyReference it) -> {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("The leaf identifier \"");
          _builder.append(name);
          _builder.append("\" must not appear more than once in a key.");
          final String message = _builder.toString();
          final int index = key.getReferences().indexOf(it);
          this.error(message, key, YangPackage.Literals.KEY__REFERENCES, index, IssueCodes.KEY_DUPLICATE_LEAF_NAME);
        };
        nodesWithSameName.forEach(_function_3);
      }
    };
    IterableExtensions2.<String, KeyReference>toMultimap(IterableExtensions.<KeyReference>filter(key.getReferences(), _function), _function_1).asMap().forEach(_function_2);
    final Function1<KeyReference, Pair<KeyReference, Leaf>> _function_3 = (KeyReference it) -> {
      Leaf _node = it.getNode();
      return Pair.<KeyReference, Leaf>of(it, _node);
    };
    final Consumer<Pair<KeyReference, Leaf>> _function_4 = (Pair<KeyReference, Leaf> pair) -> {
      IfFeature _firstSubstatementsOfType = this._yangExtensions.<IfFeature>firstSubstatementsOfType(pair.getValue(), IfFeature.class);
      boolean _tripleNotEquals = (_firstSubstatementsOfType != null);
      if (_tripleNotEquals) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("A leaf that is a list key must not have any \"if-feature\" statements.");
        final String message = _builder.toString();
        this.error(message, pair.getKey(), YangPackage.Literals.KEY_REFERENCE__NODE, IssueCodes.LEAF_KEY_WITH_IF_FEATURE);
      }
    };
    IterableExtensions.<Pair<KeyReference, Leaf>>filterNull(ListExtensions.<KeyReference, Pair<KeyReference, Leaf>>map(key.getReferences(), _function_3)).forEach(_function_4);
  }
  
  @Check
  public void checkDeviate(final Deviate it) {
    final String argument = it.getArgument();
    boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(argument);
    boolean _not = (!_isNullOrEmpty);
    if (_not) {
      final Set<String> validArguments = Collections.<String>unmodifiableSet(CollectionLiterals.<String>newHashSet("not-supported", "add", "replace", "delete"));
      boolean _contains = validArguments.contains(argument);
      boolean _not_1 = (!_contains);
      if (_not_1) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("The argument of the \"deviate\" statement must be ");
        String _prettyString = IterableExtensions2.toPrettyString(validArguments, "or");
        _builder.append(_prettyString);
        _builder.append(".");
        final String message = _builder.toString();
        this.error(message, it, YangPackage.Literals.DEVIATE__ARGUMENT, IssueCodes.TYPE_ERROR);
      }
    }
  }
  
  @Check
  public void checkStatus(final Status it) {
    final String status = it.getArgument();
    boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(it.getArgument());
    boolean _not = (!_isNullOrEmpty);
    if (_not) {
      final Set<String> validArguments = Collections.<String>unmodifiableSet(CollectionLiterals.<String>newHashSet("current", "deprecated", "obsolete"));
      boolean _contains = validArguments.contains(status);
      boolean _not_1 = (!_contains);
      if (_not_1) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("The argument of the \"status\" statement must be ");
        String _prettyString = IterableExtensions2.toPrettyString(validArguments, "or");
        _builder.append(_prettyString);
        _builder.append(".");
        final String message = _builder.toString();
        this.error(message, it, YangPackage.Literals.STATUS__ARGUMENT, IssueCodes.TYPE_ERROR);
      }
    }
  }
  
  @Check
  public void checkAugment(final Augment it) {
    SchemaNodeIdentifier _path = it.getPath();
    SchemaNode _schemaNode = null;
    if (_path!=null) {
      _schemaNode=_path.getSchemaNode();
    }
    final SchemaNode target = _schemaNode;
    if ((target != null)) {
      final Collection<EClass> validSubstatements = this.validAugmentStatements.get(target.eClass());
      boolean _isNullOrEmpty = IterableExtensions.isNullOrEmpty(validSubstatements);
      if (_isNullOrEmpty) {
        if (((target.eClass() == YangPackage.Literals.RPC) || (target.eClass() == YangPackage.Literals.ACTION))) {
          final String lastSegment = this.getLastPathSegment(it.getPath());
          if ((Objects.equal(lastSegment, "input") || Objects.equal(lastSegment, "output"))) {
            final QualifiedName fqn = this.qualifiedNameProvider.getFullyQualifiedName(target);
            if ((fqn != null)) {
              final IScope scope = this.scopeProvider.getScope(target, YangPackage.Literals.STATEMENT__SUBSTATEMENTS);
              final io.typefox.yang.yang.Module mainModule = this._yangExtensions.getMainModule(target);
              if ((mainModule == null)) {
                StringConcatenation _builder = new StringConcatenation();
                _builder.append("The augment\'s target lacks a main module.");
                this.error(_builder.toString(), it, YangPackage.Literals.AUGMENT__PATH, IssueCodes.INVALID_AUGMENTATION);
                return;
              }
              final QualifiedName inputOrOutputFqn = fqn.append(this._yangExtensions.getMainModule(target).getName()).append(lastSegment);
              IEObjectDescription _singleElement = scope.getSingleElement(inputOrOutputFqn);
              boolean _tripleNotEquals = (_singleElement != null);
              if (_tripleNotEquals) {
                return;
              }
            }
          }
        }
        final Function1<EClass, String> _function = (EClass it_1) -> {
          return YangNameUtils.getYangName(it_1);
        };
        final String validTypes = IterableExtensions2.toPrettyString(IterableExtensions.<EClass, String>map(this.validAugmentStatements.keySet(), _function), "or");
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("The augment\'s target node must be either a ");
        _builder_1.append(validTypes);
        _builder_1.append(" node.");
        final String message = _builder_1.toString();
        this.error(message, it, YangPackage.Literals.AUGMENT__PATH, IssueCodes.INVALID_AUGMENTATION);
      } else {
        final Iterable<SchemaNode> schemaNodes = Iterables.<SchemaNode>filter(it.getSubstatements(), SchemaNode.class);
        if (((target.eClass() == YangPackage.Literals.CHOICE) && (IterableExtensions.size(schemaNodes) == 1))) {
          if (((!this.validShorthandStatements.contains(IterableExtensions.<SchemaNode>head(schemaNodes).eClass())) && 
            (IterableExtensions.<SchemaNode>head(schemaNodes).eClass() != YangPackage.Literals.CASE))) {
            StringConcatenation _builder_2 = new StringConcatenation();
            _builder_2.append("If the target node is a \"choice\" node, the \"case\" statement or a shorthand \"case\" statement can be used within the \"augment\" statement.");
            final String message_1 = _builder_2.toString();
            this.error(message_1, IterableExtensions.<SchemaNode>head(schemaNodes), YangPackage.Literals.SCHEMA_NODE__NAME, IssueCodes.INVALID_AUGMENTATION);
          }
        } else {
          final Consumer<SchemaNode> _function_1 = (SchemaNode it_1) -> {
            boolean _contains = validSubstatements.contains(it_1.eClass());
            boolean _not = (!_contains);
            if (_not) {
              final Function1<EClass, String> _function_2 = (EClass it_2) -> {
                return YangNameUtils.getYangName(it_2);
              };
              final String validTypes_1 = IterableExtensions2.toPrettyString(IterableExtensions.<EClass, String>map(validSubstatements, _function_2), "or");
              StringConcatenation _builder_3 = new StringConcatenation();
              _builder_3.append("If the target node is a \"");
              String _yangName = YangNameUtils.getYangName(target.eClass());
              _builder_3.append(_yangName);
              _builder_3.append("\" node, a ");
              _builder_3.append(validTypes_1);
              _builder_3.append(" statements can be used within the \"augment\" statement.");
              final String message_2 = _builder_3.toString();
              this.error(message_2, it_1, YangPackage.Literals.SCHEMA_NODE__NAME, IssueCodes.INVALID_AUGMENTATION);
            }
          };
          schemaNodes.forEach(_function_1);
        }
      }
    }
  }
  
  @Check
  public void checkAction(final Action it) {
    this.checkAncestors(it, YangPackage.Literals.SCHEMA_NODE__NAME);
  }
  
  @Check
  public void checkNotification(final Notification it) {
    this.checkAncestors(it, YangPackage.Literals.SCHEMA_NODE__NAME);
  }
  
  private void checkAncestors(final Statement it, final EStructuralFeature feature) {
    final String name = YangNameUtils.getYangName(it);
    EObject ancestor = it.eContainer();
    while ((ancestor instanceof Statement)) {
      {
        if ((ancestor instanceof io.typefox.yang.yang.List)) {
          Key _firstSubstatementsOfType = this._yangExtensions.<Key>firstSubstatementsOfType(((Statement)ancestor), Key.class);
          boolean _tripleEquals = (_firstSubstatementsOfType == null);
          if (_tripleEquals) {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("\"");
            _builder.append(name);
            _builder.append("\" node must not have any ancestor node that is a list node without a \"key\" statement.");
            final String message = _builder.toString();
            this.error(message, it, feature, IssueCodes.INVALID_ANCESTOR);
          }
        } else {
          if ((((ancestor instanceof Action) || (ancestor instanceof Rpc)) || (ancestor instanceof Notification))) {
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("\"");
            _builder_1.append(name);
            _builder_1.append("\" node must not be defined within a \"");
            String _yangName = YangNameUtils.getYangName(ancestor);
            _builder_1.append(_yangName);
            _builder_1.append("\" statement.");
            final String message_1 = _builder_1.toString();
            this.error(message_1, it, feature, IssueCodes.INVALID_ANCESTOR);
          }
        }
        ancestor = ((Statement)ancestor).eContainer();
      }
    }
  }
  
  @Check
  public void checkIdentity(final Identity it) {
    final Function1<Identity, Identity> _function = (Identity it_1) -> {
      Base _firstSubstatementsOfType = this._yangExtensions.<Base>firstSubstatementsOfType(it_1, Base.class);
      Identity _reference = null;
      if (_firstSubstatementsOfType!=null) {
        _reference=_firstSubstatementsOfType.getReference();
      }
      return _reference;
    };
    final Function1<? super Identity, ? extends Identity> getBase = _function;
    Identity base = getBase.apply(it);
    while ((base != null)) {
      {
        boolean _equals = Objects.equal(it, base);
        if (_equals) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("An identity must not reference itself, neither directly nor indirectly through a chain of other identities.");
          final String message = _builder.toString();
          this.error(message, it, YangPackage.Literals.SCHEMA_NODE__NAME, IssueCodes.IDENTITY_CYCLE);
        }
        base = getBase.apply(base);
      }
    }
  }
  
  @Check
  public void checkDefault(final Choice it) {
    final Default default_ = this._yangExtensions.<Default>firstSubstatementsOfType(it, Default.class);
    if ((default_ != null)) {
      final Mandatory mandatory = this._yangExtensions.<Mandatory>firstSubstatementsOfType(it, Mandatory.class);
      String _isMandatory = null;
      if (mandatory!=null) {
        _isMandatory=mandatory.getIsMandatory();
      }
      boolean _equals = Objects.equal("true", _isMandatory);
      if (_equals) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("The \"default\" statement must not be present on choices where \"mandatory\" is \"true\"");
        final String message = _builder.toString();
        this.error(message, it, YangPackage.Literals.SCHEMA_NODE__NAME, IssueCodes.INVALID_DEFAULT);
      }
      final EList<Statement> substatements = it.getSubstatements();
      final int length = ((Object[])Conversions.unwrapArray(substatements, Object.class)).length;
      final int index = substatements.indexOf(default_);
      if (((index > 0) && (index < (length - 1)))) {
        for (int i = index; (i < length); i++) {
          {
            final Statement statement = substatements.get(i);
            boolean _isMandatory_1 = this.isMandatory(statement);
            if (_isMandatory_1) {
              StringConcatenation _builder_1 = new StringConcatenation();
              _builder_1.append("There must not be any mandatory nodes directly under the default case.");
              final String message_1 = _builder_1.toString();
              this.error(message_1, statement, null, IssueCodes.MANDATORY_AFTER_DEFAULT_CASE);
            }
          }
        }
      }
    }
  }
  
  /**
   * Returns {@code true} if the argument is a mandatory node, otherwise {@code false}.
   * A mandatory node is one of:
   * <ul>
   * <li>A leaf, choice, anydata, or anyxml node with a "mandatory" statement with the value "true".</li>
   * <li>A list or leaf-list node with a "min-elements" statement with a value greater than zero.</li>
   * <li>A container node without a "presence" statement and that has at least one mandatory node as a child.</li>
   * </ul>
   * See: https://tools.ietf.org/html/rfc7950#section-3
   */
  private boolean isMandatory(final Statement it) {
    boolean _switchResult = false;
    boolean _matched = false;
    if (Objects.equal(it, Leaf.class)) {
      _matched=true;
    }
    if (!_matched) {
      if (it instanceof Choice) {
        _matched=true;
      }
    }
    if (!_matched) {
      if (it instanceof Anydata) {
        _matched=true;
      }
    }
    if (!_matched) {
      if (it instanceof Anyxml) {
        _matched=true;
      }
    }
    if (_matched) {
      Mandatory _firstSubstatementsOfType = this._yangExtensions.<Mandatory>firstSubstatementsOfType(it, Mandatory.class);
      String _isMandatory = null;
      if (_firstSubstatementsOfType!=null) {
        _isMandatory=_firstSubstatementsOfType.getIsMandatory();
      }
      _switchResult = Objects.equal("true", _isMandatory);
    }
    if (!_matched) {
      if (Objects.equal(it, io.typefox.yang.yang.List.class)) {
        _matched=true;
      }
      if (!_matched) {
        if (it instanceof LeafList) {
          _matched=true;
        }
      }
      if (_matched) {
        MinElements _firstSubstatementsOfType_1 = this._yangExtensions.<MinElements>firstSubstatementsOfType(it, MinElements.class);
        String _minElements = null;
        if (_firstSubstatementsOfType_1!=null) {
          _minElements=_firstSubstatementsOfType_1.getMinElements();
        }
        final Integer value = this.getParseIntSafe(_minElements);
        return ((value != null) && (value.intValue() > 0));
      }
    }
    if (!_matched) {
      if (Objects.equal(it, Choice.class)) {
        _matched=true;
        _switchResult = (IterableExtensions.isNullOrEmpty(this._yangExtensions.<Presence>substatementsOfType(it, Presence.class)) && IterableExtensions.<Statement>exists(it.getSubstatements(), ((Function1<Statement, Boolean>) (Statement it_1) -> {
          return Boolean.valueOf(this.isMandatory(it_1));
        })));
      }
    }
    if (!_matched) {
      _switchResult = false;
    }
    return _switchResult;
  }
  
  /**
   * Returns with the text of the last non-hidden leaf node of the argument, or {@code null}.
   */
  private String getLastPathSegment(final SchemaNodeIdentifier it) {
    final ICompositeNode node = NodeModelUtils.findActualNodeFor(it);
    if ((node != null)) {
      final Iterator<ILeafNode> itr = ListExtensions.<ILeafNode>reverse(IterableExtensions.<ILeafNode>toList(node.getLeafNodes())).iterator();
      while (itr.hasNext()) {
        {
          final ILeafNode leafNode = itr.next();
          boolean _isHidden = leafNode.isHidden();
          boolean _not = (!_isHidden);
          if (_not) {
            return leafNode.getText();
          }
        }
      }
    }
    return null;
  }
  
  private Integer getParseIntSafe(final String it) {
    Integer _xtrycatchfinallyexpression = null;
    try {
      Integer _xifexpression = null;
      boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(it);
      if (_isNullOrEmpty) {
        _xifexpression = null;
      } else {
        _xifexpression = Integer.valueOf(Integer.parseInt(it));
      }
      _xtrycatchfinallyexpression = _xifexpression;
    } catch (final Throwable _t) {
      if (_t instanceof NumberFormatException) {
        _xtrycatchfinallyexpression = null;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    return _xtrycatchfinallyexpression;
  }
}
