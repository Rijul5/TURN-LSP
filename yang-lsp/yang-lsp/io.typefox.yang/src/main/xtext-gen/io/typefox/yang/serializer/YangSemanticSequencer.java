/*
 * generated by Xtext 2.16.0-SNAPSHOT
 */
package io.typefox.yang.serializer;

import com.google.inject.Inject;
import io.typefox.yang.services.YangGrammarAccess;
import io.typefox.yang.yang.AbbrevAttributeStep;
import io.typefox.yang.yang.AbsolutePath;
import io.typefox.yang.yang.Anydata;
import io.typefox.yang.yang.Anyxml;
import io.typefox.yang.yang.Argument;
import io.typefox.yang.yang.Augment;
import io.typefox.yang.yang.Base;
import io.typefox.yang.yang.BelongsTo;
import io.typefox.yang.yang.BinaryOperation;
import io.typefox.yang.yang.BinaryOperator;
import io.typefox.yang.yang.Bit;
import io.typefox.yang.yang.Case;
import io.typefox.yang.yang.Choice;
import io.typefox.yang.yang.Config;
import io.typefox.yang.yang.Contact;
import io.typefox.yang.yang.Container;
import io.typefox.yang.yang.CurrentRef;
import io.typefox.yang.yang.Default;
import io.typefox.yang.yang.Description;
import io.typefox.yang.yang.Deviate;
import io.typefox.yang.yang.Deviation;
import io.typefox.yang.yang.ErrorAppTag;
import io.typefox.yang.yang.ErrorMessage;
import io.typefox.yang.yang.Extension;
import io.typefox.yang.yang.Feature;
import io.typefox.yang.yang.FeatureReference;
import io.typefox.yang.yang.FractionDigits;
import io.typefox.yang.yang.Grouping;
import io.typefox.yang.yang.GroupingRef;
import io.typefox.yang.yang.Identity;
import io.typefox.yang.yang.IfFeature;
import io.typefox.yang.yang.Import;
import io.typefox.yang.yang.Include;
import io.typefox.yang.yang.Input;
import io.typefox.yang.yang.Key;
import io.typefox.yang.yang.KeyReference;
import io.typefox.yang.yang.Leaf;
import io.typefox.yang.yang.LeafList;
import io.typefox.yang.yang.Length;
import io.typefox.yang.yang.List;
import io.typefox.yang.yang.Literal;
import io.typefox.yang.yang.Mandatory;
import io.typefox.yang.yang.Max;
import io.typefox.yang.yang.MaxElements;
import io.typefox.yang.yang.Min;
import io.typefox.yang.yang.MinElements;
import io.typefox.yang.yang.Modifier;
import io.typefox.yang.yang.Must;
import io.typefox.yang.yang.Namespace;
import io.typefox.yang.yang.Notification;
import io.typefox.yang.yang.OrderedBy;
import io.typefox.yang.yang.Organization;
import io.typefox.yang.yang.Output;
import io.typefox.yang.yang.ParentRef;
import io.typefox.yang.yang.Path;
import io.typefox.yang.yang.Pattern;
import io.typefox.yang.yang.Position;
import io.typefox.yang.yang.Prefix;
import io.typefox.yang.yang.Presence;
import io.typefox.yang.yang.ProcessingInstruction;
import io.typefox.yang.yang.Range;
import io.typefox.yang.yang.Reference;
import io.typefox.yang.yang.Refine;
import io.typefox.yang.yang.RelativePath;
import io.typefox.yang.yang.RequireInstance;
import io.typefox.yang.yang.Revision;
import io.typefox.yang.yang.RevisionDate;
import io.typefox.yang.yang.Rpc;
import io.typefox.yang.yang.SchemaNodeIdentifier;
import io.typefox.yang.yang.Status;
import io.typefox.yang.yang.Submodule;
import io.typefox.yang.yang.Type;
import io.typefox.yang.yang.TypeReference;
import io.typefox.yang.yang.Typedef;
import io.typefox.yang.yang.UnaryOperation;
import io.typefox.yang.yang.Unique;
import io.typefox.yang.yang.Units;
import io.typefox.yang.yang.Unknown;
import io.typefox.yang.yang.UnparsedXpath;
import io.typefox.yang.yang.Uses;
import io.typefox.yang.yang.Value;
import io.typefox.yang.yang.When;
import io.typefox.yang.yang.XpathAdditiveOperation;
import io.typefox.yang.yang.XpathAndOperation;
import io.typefox.yang.yang.XpathEqualityOperation;
import io.typefox.yang.yang.XpathFilter;
import io.typefox.yang.yang.XpathFunctionCall;
import io.typefox.yang.yang.XpathLocation;
import io.typefox.yang.yang.XpathMultiplicativeOperation;
import io.typefox.yang.yang.XpathNameTest;
import io.typefox.yang.yang.XpathNodeType;
import io.typefox.yang.yang.XpathNumberLiteral;
import io.typefox.yang.yang.XpathOrOperation;
import io.typefox.yang.yang.XpathRelationalOperation;
import io.typefox.yang.yang.XpathStep;
import io.typefox.yang.yang.XpathStringLiteral;
import io.typefox.yang.yang.XpathUnaryOperation;
import io.typefox.yang.yang.XpathUnionOperation;
import io.typefox.yang.yang.XpathVariableReference;
import io.typefox.yang.yang.YangPackage;
import io.typefox.yang.yang.YangVersion;
import io.typefox.yang.yang.YinElement;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class YangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private YangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == YangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case YangPackage.ABBREV_ATTRIBUTE_STEP:
				sequence_XpathStep(context, (AbbrevAttributeStep) semanticObject); 
				return; 
			case YangPackage.ABSOLUTE_PATH:
				sequence_XpathPrimaryExpr(context, (AbsolutePath) semanticObject); 
				return; 
			case YangPackage.ACTION:
				sequence_Action_StatementEnd(context, (io.typefox.yang.yang.Action) semanticObject); 
				return; 
			case YangPackage.ANYDATA:
				sequence_Anydata_StatementEnd(context, (Anydata) semanticObject); 
				return; 
			case YangPackage.ANYXML:
				sequence_Anyxml_StatementEnd(context, (Anyxml) semanticObject); 
				return; 
			case YangPackage.ARGUMENT:
				sequence_Argument_StatementEnd(context, (Argument) semanticObject); 
				return; 
			case YangPackage.AUGMENT:
				sequence_Augment_StatementEnd(context, (Augment) semanticObject); 
				return; 
			case YangPackage.BASE:
				sequence_Base_StatementEnd(context, (Base) semanticObject); 
				return; 
			case YangPackage.BELONGS_TO:
				sequence_BelongsTo_StatementEnd(context, (BelongsTo) semanticObject); 
				return; 
			case YangPackage.BINARY_OPERATION:
				if (rule == grammarAccess.getRangeRefinementExpressionRule()) {
					sequence_RangeRefinementExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRefinementExpressionRule()
						|| action == grammarAccess.getRefinementExpressionAccess().getBinaryOperationLeftAction_1_0()) {
					sequence_RangeRefinementExpression_RefinementExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else break;
			case YangPackage.BINARY_OPERATOR:
				sequence_IfFeatureAndExpression_IfFeatureOrExpression(context, (BinaryOperator) semanticObject); 
				return; 
			case YangPackage.BIT:
				sequence_Bit_StatementEnd(context, (Bit) semanticObject); 
				return; 
			case YangPackage.CASE:
				sequence_Case_StatementEnd(context, (Case) semanticObject); 
				return; 
			case YangPackage.CHOICE:
				sequence_Choice_StatementEnd(context, (Choice) semanticObject); 
				return; 
			case YangPackage.CONFIG:
				sequence_Config_StatementEnd(context, (Config) semanticObject); 
				return; 
			case YangPackage.CONTACT:
				sequence_Contact_StatementEnd(context, (Contact) semanticObject); 
				return; 
			case YangPackage.CONTAINER:
				sequence_Container_StatementEnd(context, (Container) semanticObject); 
				return; 
			case YangPackage.CURRENT_REF:
				sequence_XpathStep(context, (CurrentRef) semanticObject); 
				return; 
			case YangPackage.DEFAULT:
				sequence_Default_StatementEnd(context, (Default) semanticObject); 
				return; 
			case YangPackage.DESCRIPTION:
				sequence_Description_StatementEnd(context, (Description) semanticObject); 
				return; 
			case YangPackage.DEVIATE:
				sequence_Deviate_StatementEnd(context, (Deviate) semanticObject); 
				return; 
			case YangPackage.DEVIATION:
				sequence_Deviation_StatementEnd(context, (Deviation) semanticObject); 
				return; 
			case YangPackage.ENUM:
				sequence_Enum_StatementEnd(context, (io.typefox.yang.yang.Enum) semanticObject); 
				return; 
			case YangPackage.ERROR_APP_TAG:
				sequence_ErrorAppTag_StatementEnd(context, (ErrorAppTag) semanticObject); 
				return; 
			case YangPackage.ERROR_MESSAGE:
				sequence_ErrorMessage_StatementEnd(context, (ErrorMessage) semanticObject); 
				return; 
			case YangPackage.EXTENSION:
				sequence_Extension_StatementEnd(context, (Extension) semanticObject); 
				return; 
			case YangPackage.FEATURE:
				sequence_Feature_StatementEnd(context, (Feature) semanticObject); 
				return; 
			case YangPackage.FEATURE_REFERENCE:
				sequence_IfFeatureExpression(context, (FeatureReference) semanticObject); 
				return; 
			case YangPackage.FRACTION_DIGITS:
				sequence_FractionDigits_StatementEnd(context, (FractionDigits) semanticObject); 
				return; 
			case YangPackage.GROUPING:
				sequence_Grouping_StatementEnd(context, (Grouping) semanticObject); 
				return; 
			case YangPackage.GROUPING_REF:
				sequence_GroupingRef(context, (GroupingRef) semanticObject); 
				return; 
			case YangPackage.IDENTITY:
				sequence_Identity_StatementEnd(context, (Identity) semanticObject); 
				return; 
			case YangPackage.IF_FEATURE:
				sequence_IfFeature_StatementEnd(context, (IfFeature) semanticObject); 
				return; 
			case YangPackage.IMPORT:
				sequence_Import_StatementEnd(context, (Import) semanticObject); 
				return; 
			case YangPackage.INCLUDE:
				sequence_Include_StatementEnd(context, (Include) semanticObject); 
				return; 
			case YangPackage.INPUT:
				sequence_Input_StatementEnd(context, (Input) semanticObject); 
				return; 
			case YangPackage.KEY:
				sequence_Key_StatementEnd(context, (Key) semanticObject); 
				return; 
			case YangPackage.KEY_REFERENCE:
				sequence_KeyReference(context, (KeyReference) semanticObject); 
				return; 
			case YangPackage.LEAF:
				sequence_Leaf_StatementEnd(context, (Leaf) semanticObject); 
				return; 
			case YangPackage.LEAF_LIST:
				sequence_LeafList_StatementEnd(context, (LeafList) semanticObject); 
				return; 
			case YangPackage.LENGTH:
				sequence_Length_StatementEnd(context, (Length) semanticObject); 
				return; 
			case YangPackage.LIST:
				sequence_List_StatementEnd(context, (List) semanticObject); 
				return; 
			case YangPackage.LITERAL:
				sequence_ExplicitRefinementExpression(context, (Literal) semanticObject); 
				return; 
			case YangPackage.MANDATORY:
				sequence_Mandatory_StatementEnd(context, (Mandatory) semanticObject); 
				return; 
			case YangPackage.MAX:
				sequence_ExplicitRefinementExpression(context, (Max) semanticObject); 
				return; 
			case YangPackage.MAX_ELEMENTS:
				sequence_MaxElements_StatementEnd(context, (MaxElements) semanticObject); 
				return; 
			case YangPackage.MIN:
				sequence_ExplicitRefinementExpression(context, (Min) semanticObject); 
				return; 
			case YangPackage.MIN_ELEMENTS:
				sequence_MinElements_StatementEnd(context, (MinElements) semanticObject); 
				return; 
			case YangPackage.MODIFIER:
				sequence_Modifier_StatementEnd(context, (Modifier) semanticObject); 
				return; 
			case YangPackage.MODULE:
				sequence_Module_StatementEnd(context, (io.typefox.yang.yang.Module) semanticObject); 
				return; 
			case YangPackage.MUST:
				sequence_Must_StatementEnd(context, (Must) semanticObject); 
				return; 
			case YangPackage.NAMESPACE:
				sequence_Namespace_StatementEnd(context, (Namespace) semanticObject); 
				return; 
			case YangPackage.NOTIFICATION:
				sequence_Notification_StatementEnd(context, (Notification) semanticObject); 
				return; 
			case YangPackage.ORDERED_BY:
				sequence_OrderedBy_StatementEnd(context, (OrderedBy) semanticObject); 
				return; 
			case YangPackage.ORGANIZATION:
				sequence_Organization_StatementEnd(context, (Organization) semanticObject); 
				return; 
			case YangPackage.OUTPUT:
				sequence_Output_StatementEnd(context, (Output) semanticObject); 
				return; 
			case YangPackage.PARENT_REF:
				sequence_XpathStep(context, (ParentRef) semanticObject); 
				return; 
			case YangPackage.PATH:
				sequence_Path_StatementEnd(context, (Path) semanticObject); 
				return; 
			case YangPackage.PATTERN:
				sequence_Pattern_StatementEnd(context, (Pattern) semanticObject); 
				return; 
			case YangPackage.POSITION:
				sequence_Position_StatementEnd(context, (Position) semanticObject); 
				return; 
			case YangPackage.PREFIX:
				sequence_Prefix_StatementEnd(context, (Prefix) semanticObject); 
				return; 
			case YangPackage.PRESENCE:
				sequence_Presence_StatementEnd(context, (Presence) semanticObject); 
				return; 
			case YangPackage.PROCESSING_INSTRUCTION:
				sequence_XpathNodeTest(context, (ProcessingInstruction) semanticObject); 
				return; 
			case YangPackage.RANGE:
				sequence_Range_StatementEnd(context, (Range) semanticObject); 
				return; 
			case YangPackage.REFERENCE:
				sequence_Reference_StatementEnd(context, (Reference) semanticObject); 
				return; 
			case YangPackage.REFINE:
				sequence_Refine_StatementEnd(context, (Refine) semanticObject); 
				return; 
			case YangPackage.RELATIVE_PATH:
				sequence_XpathPrimaryExpr(context, (RelativePath) semanticObject); 
				return; 
			case YangPackage.REQUIRE_INSTANCE:
				sequence_RequireInstance_StatementEnd(context, (RequireInstance) semanticObject); 
				return; 
			case YangPackage.REVISION:
				sequence_Revision_StatementEnd(context, (Revision) semanticObject); 
				return; 
			case YangPackage.REVISION_DATE:
				sequence_RevisionDate_StatementEnd(context, (RevisionDate) semanticObject); 
				return; 
			case YangPackage.RPC:
				sequence_Rpc_StatementEnd(context, (Rpc) semanticObject); 
				return; 
			case YangPackage.SCHEMA_NODE_IDENTIFIER:
				if (rule == grammarAccess.getDescendantSchemaNodeIdentifierRule()
						|| action == grammarAccess.getDescendantSchemaNodeIdentifierAccess().getSchemaNodeIdentifierTargetAction_1_0()) {
					sequence_DescendantRootSchemaNodeIdentifier_DescendantSchemaNodeIdentifier(context, (SchemaNodeIdentifier) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDescendantRootSchemaNodeIdentifierRule()) {
					sequence_DescendantRootSchemaNodeIdentifier(context, (SchemaNodeIdentifier) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRootSchemaNodeIdentifierRule()) {
					sequence_RootSchemaNodeIdentifier(context, (SchemaNodeIdentifier) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSchemaNodeIdentifierRule()
						|| action == grammarAccess.getSchemaNodeIdentifierAccess().getSchemaNodeIdentifierTargetAction_1_0()) {
					sequence_RootSchemaNodeIdentifier_SchemaNodeIdentifier(context, (SchemaNodeIdentifier) semanticObject); 
					return; 
				}
				else break;
			case YangPackage.STATUS:
				sequence_StatementEnd_Status(context, (Status) semanticObject); 
				return; 
			case YangPackage.SUBMODULE:
				sequence_StatementEnd_Submodule(context, (Submodule) semanticObject); 
				return; 
			case YangPackage.TYPE:
				sequence_StatementEnd_Type(context, (Type) semanticObject); 
				return; 
			case YangPackage.TYPE_REFERENCE:
				sequence_TypeReference(context, (TypeReference) semanticObject); 
				return; 
			case YangPackage.TYPEDEF:
				sequence_StatementEnd_Typedef(context, (Typedef) semanticObject); 
				return; 
			case YangPackage.UNARY_OPERATION:
				sequence_IfFeatureExpression(context, (UnaryOperation) semanticObject); 
				return; 
			case YangPackage.UNIQUE:
				sequence_DescendantSchemaNodeIdentifierReferences_StatementEnd_Unique(context, (Unique) semanticObject); 
				return; 
			case YangPackage.UNITS:
				sequence_StatementEnd_Units(context, (Units) semanticObject); 
				return; 
			case YangPackage.UNKNOWN:
				sequence_StatementEnd_Unknown(context, (Unknown) semanticObject); 
				return; 
			case YangPackage.UNPARSED_XPATH:
				sequence_XpathExpression(context, (UnparsedXpath) semanticObject); 
				return; 
			case YangPackage.USES:
				sequence_StatementEnd_Uses(context, (Uses) semanticObject); 
				return; 
			case YangPackage.VALUE:
				sequence_StatementEnd_Value(context, (Value) semanticObject); 
				return; 
			case YangPackage.WHEN:
				sequence_StatementEnd_When(context, (When) semanticObject); 
				return; 
			case YangPackage.XPATH_ADDITIVE_OPERATION:
				sequence_XpathAdditiveExpr(context, (XpathAdditiveOperation) semanticObject); 
				return; 
			case YangPackage.XPATH_AND_OPERATION:
				sequence_XpathAndExpr(context, (XpathAndOperation) semanticObject); 
				return; 
			case YangPackage.XPATH_EQUALITY_OPERATION:
				sequence_XpathEqualityExpr(context, (XpathEqualityOperation) semanticObject); 
				return; 
			case YangPackage.XPATH_FILTER:
				if (rule == grammarAccess.getXpathExpressionRule()
						|| rule == grammarAccess.getParsedXpathExpressionRule()
						|| rule == grammarAccess.getXpathOrExprRule()
						|| action == grammarAccess.getXpathOrExprAccess().getXpathOrOperationLeftAction_1_0()
						|| rule == grammarAccess.getXpathAndExprRule()
						|| action == grammarAccess.getXpathAndExprAccess().getXpathAndOperationLeftAction_1_0()
						|| rule == grammarAccess.getXpathEqualityExprRule()
						|| action == grammarAccess.getXpathEqualityExprAccess().getXpathEqualityOperationLeftAction_1_0()
						|| rule == grammarAccess.getXpathRelationalExprRule()
						|| action == grammarAccess.getXpathRelationalExprAccess().getXpathRelationalOperationLeftAction_1_0()
						|| rule == grammarAccess.getXpathAdditiveExprRule()
						|| action == grammarAccess.getXpathAdditiveExprAccess().getXpathAdditiveOperationLeftAction_1_0()
						|| rule == grammarAccess.getXpathMultiplicativeExprRule()
						|| action == grammarAccess.getXpathMultiplicativeExprAccess().getXpathMultiplicativeOperationLeftAction_1_0()
						|| rule == grammarAccess.getXpathUnaryExprRule()
						|| rule == grammarAccess.getXpathUnionExprRule()
						|| action == grammarAccess.getXpathUnionExprAccess().getXpathUnionOperationLeftAction_1_0()
						|| rule == grammarAccess.getXpathPathExprRule()
						|| action == grammarAccess.getXpathPathExprAccess().getXpathLocationTargetAction_1_0()
						|| rule == grammarAccess.getXpathFilterExprRule()
						|| action == grammarAccess.getXpathFilterExprAccess().getXpathFilterTargetAction_1_0()
						|| rule == grammarAccess.getXpathPrimaryExprRule()) {
					sequence_XpathFilterExpr_XpathPathExpr(context, (XpathFilter) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getXpathPathExprAccess().getXpathFilterTargetAction_1_4_0()) {
					sequence_XpathPathExpr_XpathFilter_1_4_0(context, (XpathFilter) semanticObject); 
					return; 
				}
				else break;
			case YangPackage.XPATH_FUNCTION_CALL:
				sequence_XpathPrimaryExpr(context, (XpathFunctionCall) semanticObject); 
				return; 
			case YangPackage.XPATH_LOCATION:
				sequence_XpathPathExpr(context, (XpathLocation) semanticObject); 
				return; 
			case YangPackage.XPATH_MULTIPLICATIVE_OPERATION:
				sequence_XpathMultiplicativeExpr(context, (XpathMultiplicativeOperation) semanticObject); 
				return; 
			case YangPackage.XPATH_NAME_TEST:
				sequence_XpathNameTest(context, (XpathNameTest) semanticObject); 
				return; 
			case YangPackage.XPATH_NODE_TYPE:
				sequence_XpathNodeTest(context, (XpathNodeType) semanticObject); 
				return; 
			case YangPackage.XPATH_NUMBER_LITERAL:
				sequence_XpathPrimaryExpr(context, (XpathNumberLiteral) semanticObject); 
				return; 
			case YangPackage.XPATH_OR_OPERATION:
				sequence_XpathOrExpr(context, (XpathOrOperation) semanticObject); 
				return; 
			case YangPackage.XPATH_RELATIONAL_OPERATION:
				sequence_XpathRelationalExpr(context, (XpathRelationalOperation) semanticObject); 
				return; 
			case YangPackage.XPATH_STEP:
				sequence_XpathStep(context, (XpathStep) semanticObject); 
				return; 
			case YangPackage.XPATH_STRING_LITERAL:
				sequence_XpathPrimaryExpr(context, (XpathStringLiteral) semanticObject); 
				return; 
			case YangPackage.XPATH_UNARY_OPERATION:
				sequence_XpathUnaryExpr(context, (XpathUnaryOperation) semanticObject); 
				return; 
			case YangPackage.XPATH_UNION_OPERATION:
				sequence_XpathUnionExpr(context, (XpathUnionOperation) semanticObject); 
				return; 
			case YangPackage.XPATH_VARIABLE_REFERENCE:
				sequence_XpathPrimaryExpr(context, (XpathVariableReference) semanticObject); 
				return; 
			case YangPackage.YANG_VERSION:
				sequence_StatementEnd_YangVersion(context, (YangVersion) semanticObject); 
				return; 
			case YangPackage.YIN_ELEMENT:
				sequence_StatementEnd_YinElement(context, (YinElement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Statement returns Action
	 *     SchemaNode returns Action
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Action_StatementEnd(ISerializationContext context, io.typefox.yang.yang.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Anydata
	 *     SchemaNode returns Anydata
	 *     DataSchemaNode returns Anydata
	 *     Anydata returns Anydata
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Anydata_StatementEnd(ISerializationContext context, Anydata semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Anyxml
	 *     SchemaNode returns Anyxml
	 *     DataSchemaNode returns Anyxml
	 *     Anyxml returns Anyxml
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Anyxml_StatementEnd(ISerializationContext context, Anyxml semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Argument
	 *     OtherStatement returns Argument
	 *     Argument returns Argument
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Argument_StatementEnd(ISerializationContext context, Argument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Augment
	 *     OtherStatement returns Augment
	 *     Augment returns Augment
	 *
	 * Constraint:
	 *     (path=SchemaNodeIdentifier substatements+=Statement*)
	 */
	protected void sequence_Augment_StatementEnd(ISerializationContext context, Augment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Base
	 *     OtherStatement returns Base
	 *     Base returns Base
	 *
	 * Constraint:
	 *     (reference=[Identity|QNAME] substatements+=Statement*)
	 */
	protected void sequence_Base_StatementEnd(ISerializationContext context, Base semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BelongsTo
	 *     OtherStatement returns BelongsTo
	 *     BelongsTo returns BelongsTo
	 *
	 * Constraint:
	 *     (module=[Module|StringValue] substatements+=Statement*)
	 */
	protected void sequence_BelongsTo_StatementEnd(ISerializationContext context, BelongsTo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Bit
	 *     OtherStatement returns Bit
	 *     Enumerable returns Bit
	 *     Bit returns Bit
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Bit_StatementEnd(ISerializationContext context, Bit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Case
	 *     SchemaNode returns Case
	 *     DataSchemaNode returns Case
	 *     Case returns Case
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Case_StatementEnd(ISerializationContext context, Case semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Choice
	 *     SchemaNode returns Choice
	 *     DataSchemaNode returns Choice
	 *     Choice returns Choice
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Choice_StatementEnd(ISerializationContext context, Choice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Config
	 *     OtherStatement returns Config
	 *     Config returns Config
	 *
	 * Constraint:
	 *     (isConfig=StringValue substatements+=Statement*)
	 */
	protected void sequence_Config_StatementEnd(ISerializationContext context, Config semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Contact
	 *     OtherStatement returns Contact
	 *     Contact returns Contact
	 *
	 * Constraint:
	 *     (contact=StringValue substatements+=Statement*)
	 */
	protected void sequence_Contact_StatementEnd(ISerializationContext context, Contact semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Container
	 *     SchemaNode returns Container
	 *     DataSchemaNode returns Container
	 *     Container returns Container
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Container_StatementEnd(ISerializationContext context, Container semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Default
	 *     OtherStatement returns Default
	 *     Default returns Default
	 *
	 * Constraint:
	 *     (defaultStringValue=StringValue substatements+=Statement*)
	 */
	protected void sequence_Default_StatementEnd(ISerializationContext context, Default semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DescendantSchemaNodeIdentifier returns SchemaNodeIdentifier
	 *     DescendantSchemaNodeIdentifier.SchemaNodeIdentifier_1_0 returns SchemaNodeIdentifier
	 *
	 * Constraint:
	 *     ((target=DescendantSchemaNodeIdentifier_SchemaNodeIdentifier_1_0 schemaNode=[SchemaNode|QNAME]) | schemaNode=[SchemaNode|QNAME])
	 */
	protected void sequence_DescendantRootSchemaNodeIdentifier_DescendantSchemaNodeIdentifier(ISerializationContext context, SchemaNodeIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DescendantRootSchemaNodeIdentifier returns SchemaNodeIdentifier
	 *
	 * Constraint:
	 *     schemaNode=[SchemaNode|QNAME]
	 */
	protected void sequence_DescendantRootSchemaNodeIdentifier(ISerializationContext context, SchemaNodeIdentifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.SCHEMA_NODE_IDENTIFIER__SCHEMA_NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.SCHEMA_NODE_IDENTIFIER__SCHEMA_NODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDescendantRootSchemaNodeIdentifierAccess().getSchemaNodeSchemaNodeQNAMEParserRuleCall_0_1(), semanticObject.eGet(YangPackage.Literals.SCHEMA_NODE_IDENTIFIER__SCHEMA_NODE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Unique
	 *     OtherStatement returns Unique
	 *     Unique returns Unique
	 *
	 * Constraint:
	 *     (references+=DescendantSchemaNodeIdentifier+ substatements+=Statement*)
	 */
	protected void sequence_DescendantSchemaNodeIdentifierReferences_StatementEnd_Unique(ISerializationContext context, Unique semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Description
	 *     OtherStatement returns Description
	 *     Description returns Description
	 *
	 * Constraint:
	 *     (description=StringValue substatements+=Statement*)
	 */
	protected void sequence_Description_StatementEnd(ISerializationContext context, Description semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Deviate
	 *     OtherStatement returns Deviate
	 *     Deviate returns Deviate
	 *
	 * Constraint:
	 *     (argument=StringValue substatements+=Statement*)
	 */
	protected void sequence_Deviate_StatementEnd(ISerializationContext context, Deviate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Deviation
	 *     OtherStatement returns Deviation
	 *     Deviation returns Deviation
	 *
	 * Constraint:
	 *     (reference=SchemaNodeIdentifier substatements+=Statement*)
	 */
	protected void sequence_Deviation_StatementEnd(ISerializationContext context, Deviation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Enum
	 *     OtherStatement returns Enum
	 *     Enumerable returns Enum
	 *     Enum returns Enum
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Enum_StatementEnd(ISerializationContext context, io.typefox.yang.yang.Enum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ErrorAppTag
	 *     OtherStatement returns ErrorAppTag
	 *     ErrorAppTag returns ErrorAppTag
	 *
	 * Constraint:
	 *     (tag=StringValue substatements+=Statement*)
	 */
	protected void sequence_ErrorAppTag_StatementEnd(ISerializationContext context, ErrorAppTag semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ErrorMessage
	 *     OtherStatement returns ErrorMessage
	 *     ErrorMessage returns ErrorMessage
	 *
	 * Constraint:
	 *     (message=StringValue substatements+=Statement*)
	 */
	protected void sequence_ErrorMessage_StatementEnd(ISerializationContext context, ErrorMessage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RefinementExpression returns Literal
	 *     RefinementExpression.BinaryOperation_1_0 returns Literal
	 *     RangeRefinementExpression returns Literal
	 *     RangeRefinementExpression.BinaryOperation_1_0 returns Literal
	 *     ExplicitRefinementExpression returns Literal
	 *
	 * Constraint:
	 *     value=NUMBER
	 */
	protected void sequence_ExplicitRefinementExpression(ISerializationContext context, Literal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExplicitRefinementExpressionAccess().getValueNUMBERTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RefinementExpression returns Max
	 *     RefinementExpression.BinaryOperation_1_0 returns Max
	 *     RangeRefinementExpression returns Max
	 *     RangeRefinementExpression.BinaryOperation_1_0 returns Max
	 *     ExplicitRefinementExpression returns Max
	 *
	 * Constraint:
	 *     {Max}
	 */
	protected void sequence_ExplicitRefinementExpression(ISerializationContext context, Max semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RefinementExpression returns Min
	 *     RefinementExpression.BinaryOperation_1_0 returns Min
	 *     RangeRefinementExpression returns Min
	 *     RangeRefinementExpression.BinaryOperation_1_0 returns Min
	 *     ExplicitRefinementExpression returns Min
	 *
	 * Constraint:
	 *     {Min}
	 */
	protected void sequence_ExplicitRefinementExpression(ISerializationContext context, Min semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Extension
	 *     SchemaNode returns Extension
	 *     Extension returns Extension
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Extension_StatementEnd(ISerializationContext context, Extension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Feature
	 *     SchemaNode returns Feature
	 *     Feature returns Feature
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Feature_StatementEnd(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns FractionDigits
	 *     OtherStatement returns FractionDigits
	 *     FractionDigits returns FractionDigits
	 *
	 * Constraint:
	 *     (range=StringValue substatements+=Statement*)
	 */
	protected void sequence_FractionDigits_StatementEnd(ISerializationContext context, FractionDigits semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroupingRef returns GroupingRef
	 *
	 * Constraint:
	 *     node=[Grouping|QNAME]
	 */
	protected void sequence_GroupingRef(ISerializationContext context, GroupingRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.GROUPING_REF__NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.GROUPING_REF__NODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGroupingRefAccess().getNodeGroupingQNAMEParserRuleCall_0_1(), semanticObject.eGet(YangPackage.Literals.GROUPING_REF__NODE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Grouping
	 *     SchemaNode returns Grouping
	 *     Grouping returns Grouping
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Grouping_StatementEnd(ISerializationContext context, Grouping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Identity
	 *     SchemaNode returns Identity
	 *     Identity returns Identity
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Identity_StatementEnd(ISerializationContext context, Identity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfFeatureOrExpression returns BinaryOperator
	 *     IfFeatureOrExpression.BinaryOperator_1_0 returns BinaryOperator
	 *     IfFeatureAndExpression returns BinaryOperator
	 *     IfFeatureAndExpression.BinaryOperator_1_0 returns BinaryOperator
	 *     IfFeatureExpression returns BinaryOperator
	 *
	 * Constraint:
	 *     (
	 *         (left=IfFeatureOrExpression_BinaryOperator_1_0 operator='or' right=IfFeatureAndExpression) | 
	 *         (left=IfFeatureAndExpression_BinaryOperator_1_0 operator='and' right=IfFeatureExpression)
	 *     )
	 */
	protected void sequence_IfFeatureAndExpression_IfFeatureOrExpression(ISerializationContext context, BinaryOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfFeatureOrExpression returns FeatureReference
	 *     IfFeatureOrExpression.BinaryOperator_1_0 returns FeatureReference
	 *     IfFeatureAndExpression returns FeatureReference
	 *     IfFeatureAndExpression.BinaryOperator_1_0 returns FeatureReference
	 *     IfFeatureExpression returns FeatureReference
	 *
	 * Constraint:
	 *     feature=[Feature|QNAME]
	 */
	protected void sequence_IfFeatureExpression(ISerializationContext context, FeatureReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.FEATURE_REFERENCE__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.FEATURE_REFERENCE__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfFeatureExpressionAccess().getFeatureFeatureQNAMEParserRuleCall_0_1_0_1(), semanticObject.eGet(YangPackage.Literals.FEATURE_REFERENCE__FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IfFeatureOrExpression returns UnaryOperation
	 *     IfFeatureOrExpression.BinaryOperator_1_0 returns UnaryOperation
	 *     IfFeatureAndExpression returns UnaryOperation
	 *     IfFeatureAndExpression.BinaryOperator_1_0 returns UnaryOperation
	 *     IfFeatureExpression returns UnaryOperation
	 *
	 * Constraint:
	 *     (operator='not' target=IfFeatureExpression)
	 */
	protected void sequence_IfFeatureExpression(ISerializationContext context, UnaryOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.UNARY_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.UNARY_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.UNARY_OPERATION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.UNARY_OPERATION__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfFeatureExpressionAccess().getOperatorNotKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getIfFeatureExpressionAccess().getTargetIfFeatureExpressionParserRuleCall_1_2_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfFeature
	 *     OtherStatement returns IfFeature
	 *     IfFeature returns IfFeature
	 *
	 * Constraint:
	 *     (condition=IfFeatureOrExpression substatements+=Statement*)
	 */
	protected void sequence_IfFeature_StatementEnd(ISerializationContext context, IfFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Import
	 *     AbstractImport returns Import
	 *     OtherStatement returns Import
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (module=[AbstractModule|StringValue] substatements+=Statement*)
	 */
	protected void sequence_Import_StatementEnd(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Include
	 *     AbstractImport returns Include
	 *     OtherStatement returns Include
	 *     Include returns Include
	 *
	 * Constraint:
	 *     (module=[AbstractModule|StringValue] substatements+=Statement*)
	 */
	protected void sequence_Include_StatementEnd(ISerializationContext context, Include semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Input
	 *     SchemaNode returns Input
	 *     Input returns Input
	 *
	 * Constraint:
	 *     (name=StringValue? substatements+=Statement*)
	 */
	protected void sequence_Input_StatementEnd(ISerializationContext context, Input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyReference returns KeyReference
	 *
	 * Constraint:
	 *     node=[Leaf|QNAME]
	 */
	protected void sequence_KeyReference(ISerializationContext context, KeyReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.KEY_REFERENCE__NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.KEY_REFERENCE__NODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKeyReferenceAccess().getNodeLeafQNAMEParserRuleCall_0_1(), semanticObject.eGet(YangPackage.Literals.KEY_REFERENCE__NODE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Key
	 *     OtherStatement returns Key
	 *     Key returns Key
	 *
	 * Constraint:
	 *     (references+=KeyReference+ substatements+=Statement*)
	 */
	protected void sequence_Key_StatementEnd(ISerializationContext context, Key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LeafList
	 *     SchemaNode returns LeafList
	 *     DataSchemaNode returns LeafList
	 *     LeafList returns LeafList
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_LeafList_StatementEnd(ISerializationContext context, LeafList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Leaf
	 *     SchemaNode returns Leaf
	 *     DataSchemaNode returns Leaf
	 *     Leaf returns Leaf
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Leaf_StatementEnd(ISerializationContext context, Leaf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Length
	 *     OtherStatement returns Length
	 *     Refinable returns Length
	 *     Length returns Length
	 *
	 * Constraint:
	 *     (expression=RefinementExpression substatements+=Statement*)
	 */
	protected void sequence_Length_StatementEnd(ISerializationContext context, Length semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns List
	 *     SchemaNode returns List
	 *     DataSchemaNode returns List
	 *     List returns List
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_List_StatementEnd(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Mandatory
	 *     OtherStatement returns Mandatory
	 *     Mandatory returns Mandatory
	 *
	 * Constraint:
	 *     (isMandatory=StringValue substatements+=Statement*)
	 */
	protected void sequence_Mandatory_StatementEnd(ISerializationContext context, Mandatory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MaxElements
	 *     OtherStatement returns MaxElements
	 *     MaxElements returns MaxElements
	 *
	 * Constraint:
	 *     (maxElements=StringValue substatements+=Statement*)
	 */
	protected void sequence_MaxElements_StatementEnd(ISerializationContext context, MaxElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MinElements
	 *     OtherStatement returns MinElements
	 *     MinElements returns MinElements
	 *
	 * Constraint:
	 *     (minElements=StringValue substatements+=Statement*)
	 */
	protected void sequence_MinElements_StatementEnd(ISerializationContext context, MinElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Modifier
	 *     OtherStatement returns Modifier
	 *     Modifier returns Modifier
	 *
	 * Constraint:
	 *     (modifier=StringValue substatements+=Statement*)
	 */
	protected void sequence_Modifier_StatementEnd(ISerializationContext context, Modifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractModule returns Module
	 *     Statement returns Module
	 *     OtherStatement returns Module
	 *     Module returns Module
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Module_StatementEnd(ISerializationContext context, io.typefox.yang.yang.Module semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Must
	 *     OtherStatement returns Must
	 *     Must returns Must
	 *
	 * Constraint:
	 *     (constraint=XpathExpression substatements+=Statement*)
	 */
	protected void sequence_Must_StatementEnd(ISerializationContext context, Must semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Namespace
	 *     OtherStatement returns Namespace
	 *     Namespace returns Namespace
	 *
	 * Constraint:
	 *     (uri=StringValue substatements+=Statement*)
	 */
	protected void sequence_Namespace_StatementEnd(ISerializationContext context, Namespace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Notification
	 *     SchemaNode returns Notification
	 *     Notification returns Notification
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Notification_StatementEnd(ISerializationContext context, Notification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns OrderedBy
	 *     OtherStatement returns OrderedBy
	 *     OrderedBy returns OrderedBy
	 *
	 * Constraint:
	 *     (orderedBy=StringValue substatements+=Statement*)
	 */
	protected void sequence_OrderedBy_StatementEnd(ISerializationContext context, OrderedBy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Organization
	 *     OtherStatement returns Organization
	 *     Organization returns Organization
	 *
	 * Constraint:
	 *     (organization=StringValue substatements+=Statement*)
	 */
	protected void sequence_Organization_StatementEnd(ISerializationContext context, Organization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Output
	 *     SchemaNode returns Output
	 *     Output returns Output
	 *
	 * Constraint:
	 *     (name=StringValue? substatements+=Statement*)
	 */
	protected void sequence_Output_StatementEnd(ISerializationContext context, Output semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Path
	 *     OtherStatement returns Path
	 *     Path returns Path
	 *
	 * Constraint:
	 *     (reference=XpathExpression substatements+=Statement*)
	 */
	protected void sequence_Path_StatementEnd(ISerializationContext context, Path semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Pattern
	 *     OtherStatement returns Pattern
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (regexp=StringValue substatements+=Statement*)
	 */
	protected void sequence_Pattern_StatementEnd(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Position
	 *     OtherStatement returns Position
	 *     Ordered returns Position
	 *     Position returns Position
	 *
	 * Constraint:
	 *     (ordinal=StringValue substatements+=Statement*)
	 */
	protected void sequence_Position_StatementEnd(ISerializationContext context, Position semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Prefix
	 *     OtherStatement returns Prefix
	 *     Prefix returns Prefix
	 *
	 * Constraint:
	 *     (prefix=StringValue substatements+=Statement*)
	 */
	protected void sequence_Prefix_StatementEnd(ISerializationContext context, Prefix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Presence
	 *     OtherStatement returns Presence
	 *     Presence returns Presence
	 *
	 * Constraint:
	 *     (description=StringValue substatements+=Statement*)
	 */
	protected void sequence_Presence_StatementEnd(ISerializationContext context, Presence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RangeRefinementExpression returns BinaryOperation
	 *
	 * Constraint:
	 *     (left=RangeRefinementExpression_BinaryOperation_1_0 operator='..' right=ExplicitRefinementExpression)
	 */
	protected void sequence_RangeRefinementExpression(ISerializationContext context, BinaryOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.BINARY_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.BINARY_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeRefinementExpressionAccess().getBinaryOperationLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRangeRefinementExpressionAccess().getOperatorFullStopFullStopKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getRangeRefinementExpressionAccess().getRightExplicitRefinementExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RefinementExpression returns BinaryOperation
	 *     RefinementExpression.BinaryOperation_1_0 returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (left=RefinementExpression_BinaryOperation_1_0 operator='|' right=RangeRefinementExpression) | 
	 *         (left=RangeRefinementExpression_BinaryOperation_1_0 operator='..' right=ExplicitRefinementExpression)
	 *     )
	 */
	protected void sequence_RangeRefinementExpression_RefinementExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Range
	 *     OtherStatement returns Range
	 *     Refinable returns Range
	 *     Range returns Range
	 *
	 * Constraint:
	 *     (expression=RefinementExpression substatements+=Statement*)
	 */
	protected void sequence_Range_StatementEnd(ISerializationContext context, Range semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Reference
	 *     OtherStatement returns Reference
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     (reference=StringValue substatements+=Statement*)
	 */
	protected void sequence_Reference_StatementEnd(ISerializationContext context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Refine
	 *     OtherStatement returns Refine
	 *     Refine returns Refine
	 *
	 * Constraint:
	 *     (node=SchemaNodeIdentifier substatements+=Statement*)
	 */
	protected void sequence_Refine_StatementEnd(ISerializationContext context, Refine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RequireInstance
	 *     OtherStatement returns RequireInstance
	 *     RequireInstance returns RequireInstance
	 *
	 * Constraint:
	 *     (isRequireInstance=StringValue substatements+=Statement*)
	 */
	protected void sequence_RequireInstance_StatementEnd(ISerializationContext context, RequireInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RevisionDate
	 *     OtherStatement returns RevisionDate
	 *     RevisionDate returns RevisionDate
	 *
	 * Constraint:
	 *     (date=[Revision|StringValue] substatements+=Statement*)
	 */
	protected void sequence_RevisionDate_StatementEnd(ISerializationContext context, RevisionDate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Revision
	 *     OtherStatement returns Revision
	 *     Revision returns Revision
	 *
	 * Constraint:
	 *     (revision=StringValue substatements+=Statement*)
	 */
	protected void sequence_Revision_StatementEnd(ISerializationContext context, Revision semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RootSchemaNodeIdentifier returns SchemaNodeIdentifier
	 *
	 * Constraint:
	 *     (isAbsolute?='/'? schemaNode=[SchemaNode|QNAME])
	 */
	protected void sequence_RootSchemaNodeIdentifier(ISerializationContext context, SchemaNodeIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SchemaNodeIdentifier returns SchemaNodeIdentifier
	 *     SchemaNodeIdentifier.SchemaNodeIdentifier_1_0 returns SchemaNodeIdentifier
	 *
	 * Constraint:
	 *     ((target=SchemaNodeIdentifier_SchemaNodeIdentifier_1_0 schemaNode=[SchemaNode|QNAME]) | (isAbsolute?='/'? schemaNode=[SchemaNode|QNAME]))
	 */
	protected void sequence_RootSchemaNodeIdentifier_SchemaNodeIdentifier(ISerializationContext context, SchemaNodeIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Rpc
	 *     SchemaNode returns Rpc
	 *     Rpc returns Rpc
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_Rpc_StatementEnd(ISerializationContext context, Rpc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Status
	 *     OtherStatement returns Status
	 *     Status returns Status
	 *
	 * Constraint:
	 *     (argument=StringValue substatements+=Statement*)
	 */
	protected void sequence_StatementEnd_Status(ISerializationContext context, Status semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractModule returns Submodule
	 *     Statement returns Submodule
	 *     OtherStatement returns Submodule
	 *     Submodule returns Submodule
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_StatementEnd_Submodule(ISerializationContext context, Submodule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Type
	 *     OtherStatement returns Type
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (typeRef=TypeReference substatements+=Statement*)
	 */
	protected void sequence_StatementEnd_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Typedef
	 *     SchemaNode returns Typedef
	 *     Typedef returns Typedef
	 *
	 * Constraint:
	 *     (name=StringValue substatements+=Statement*)
	 */
	protected void sequence_StatementEnd_Typedef(ISerializationContext context, Typedef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Units
	 *     OtherStatement returns Units
	 *     Units returns Units
	 *
	 * Constraint:
	 *     (definition=StringValue substatements+=Statement*)
	 */
	protected void sequence_StatementEnd_Units(ISerializationContext context, Units semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Unknown
	 *     OtherStatement returns Unknown
	 *     Unknown returns Unknown
	 *
	 * Constraint:
	 *     (extension=[Extension|EXTENSION_NAME] name=StringValue? substatements+=Statement*)
	 */
	protected void sequence_StatementEnd_Unknown(ISerializationContext context, Unknown semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Uses
	 *     OtherStatement returns Uses
	 *     Uses returns Uses
	 *
	 * Constraint:
	 *     (grouping=GroupingRef substatements+=Statement*)
	 */
	protected void sequence_StatementEnd_Uses(ISerializationContext context, Uses semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Value
	 *     OtherStatement returns Value
	 *     Ordered returns Value
	 *     Value returns Value
	 *
	 * Constraint:
	 *     (ordinal=StringValue substatements+=Statement*)
	 */
	protected void sequence_StatementEnd_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns When
	 *     OtherStatement returns When
	 *     When returns When
	 *
	 * Constraint:
	 *     (condition=XpathExpression substatements+=Statement*)
	 */
	protected void sequence_StatementEnd_When(ISerializationContext context, When semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns YangVersion
	 *     OtherStatement returns YangVersion
	 *     YangVersion returns YangVersion
	 *
	 * Constraint:
	 *     (yangVersion=StringValue substatements+=Statement*)
	 */
	protected void sequence_StatementEnd_YangVersion(ISerializationContext context, YangVersion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns YinElement
	 *     OtherStatement returns YinElement
	 *     YinElement returns YinElement
	 *
	 * Constraint:
	 *     (isYinElement=StringValue substatements+=Statement*)
	 */
	protected void sequence_StatementEnd_YinElement(ISerializationContext context, YinElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeReference returns TypeReference
	 *
	 * Constraint:
	 *     (builtin=BUILTIN_TYPE | type=[Typedef|QualifiedTypeName])
	 */
	protected void sequence_TypeReference(ISerializationContext context, TypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns XpathAdditiveOperation
	 *     ParsedXpathExpression returns XpathAdditiveOperation
	 *     XpathOrExpr returns XpathAdditiveOperation
	 *     XpathOrExpr.XpathOrOperation_1_0 returns XpathAdditiveOperation
	 *     XpathAndExpr returns XpathAdditiveOperation
	 *     XpathAndExpr.XpathAndOperation_1_0 returns XpathAdditiveOperation
	 *     XpathEqualityExpr returns XpathAdditiveOperation
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns XpathAdditiveOperation
	 *     XpathRelationalExpr returns XpathAdditiveOperation
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns XpathAdditiveOperation
	 *     XpathAdditiveExpr returns XpathAdditiveOperation
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns XpathAdditiveOperation
	 *     XpathMultiplicativeExpr returns XpathAdditiveOperation
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns XpathAdditiveOperation
	 *     XpathUnaryExpr returns XpathAdditiveOperation
	 *     XpathUnionExpr returns XpathAdditiveOperation
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns XpathAdditiveOperation
	 *     XpathPathExpr returns XpathAdditiveOperation
	 *     XpathPathExpr.XpathLocation_1_0 returns XpathAdditiveOperation
	 *     XpathFilterExpr returns XpathAdditiveOperation
	 *     XpathFilterExpr.XpathFilter_1_0 returns XpathAdditiveOperation
	 *     XpathPrimaryExpr returns XpathAdditiveOperation
	 *
	 * Constraint:
	 *     (left=XpathAdditiveExpr_XpathAdditiveOperation_1_0 (operator='+' | operator='-') right=XpathMultiplicativeExpr)
	 */
	protected void sequence_XpathAdditiveExpr(ISerializationContext context, XpathAdditiveOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns XpathAndOperation
	 *     ParsedXpathExpression returns XpathAndOperation
	 *     XpathOrExpr returns XpathAndOperation
	 *     XpathOrExpr.XpathOrOperation_1_0 returns XpathAndOperation
	 *     XpathAndExpr returns XpathAndOperation
	 *     XpathAndExpr.XpathAndOperation_1_0 returns XpathAndOperation
	 *     XpathEqualityExpr returns XpathAndOperation
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns XpathAndOperation
	 *     XpathRelationalExpr returns XpathAndOperation
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns XpathAndOperation
	 *     XpathAdditiveExpr returns XpathAndOperation
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns XpathAndOperation
	 *     XpathMultiplicativeExpr returns XpathAndOperation
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns XpathAndOperation
	 *     XpathUnaryExpr returns XpathAndOperation
	 *     XpathUnionExpr returns XpathAndOperation
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns XpathAndOperation
	 *     XpathPathExpr returns XpathAndOperation
	 *     XpathPathExpr.XpathLocation_1_0 returns XpathAndOperation
	 *     XpathFilterExpr returns XpathAndOperation
	 *     XpathFilterExpr.XpathFilter_1_0 returns XpathAndOperation
	 *     XpathPrimaryExpr returns XpathAndOperation
	 *
	 * Constraint:
	 *     (left=XpathAndExpr_XpathAndOperation_1_0 operator='and' right=XpathEqualityExpr)
	 */
	protected void sequence_XpathAndExpr(ISerializationContext context, XpathAndOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_AND_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_AND_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_AND_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_AND_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_AND_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_AND_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathAndExprAccess().getXpathAndOperationLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXpathAndExprAccess().getOperatorAndKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getXpathAndExprAccess().getRightXpathEqualityExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns XpathEqualityOperation
	 *     ParsedXpathExpression returns XpathEqualityOperation
	 *     XpathOrExpr returns XpathEqualityOperation
	 *     XpathOrExpr.XpathOrOperation_1_0 returns XpathEqualityOperation
	 *     XpathAndExpr returns XpathEqualityOperation
	 *     XpathAndExpr.XpathAndOperation_1_0 returns XpathEqualityOperation
	 *     XpathEqualityExpr returns XpathEqualityOperation
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns XpathEqualityOperation
	 *     XpathRelationalExpr returns XpathEqualityOperation
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns XpathEqualityOperation
	 *     XpathAdditiveExpr returns XpathEqualityOperation
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns XpathEqualityOperation
	 *     XpathMultiplicativeExpr returns XpathEqualityOperation
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns XpathEqualityOperation
	 *     XpathUnaryExpr returns XpathEqualityOperation
	 *     XpathUnionExpr returns XpathEqualityOperation
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns XpathEqualityOperation
	 *     XpathPathExpr returns XpathEqualityOperation
	 *     XpathPathExpr.XpathLocation_1_0 returns XpathEqualityOperation
	 *     XpathFilterExpr returns XpathEqualityOperation
	 *     XpathFilterExpr.XpathFilter_1_0 returns XpathEqualityOperation
	 *     XpathPrimaryExpr returns XpathEqualityOperation
	 *
	 * Constraint:
	 *     (left=XpathEqualityExpr_XpathEqualityOperation_1_0 (operator='=' | operator='!=') right=XpathRelationalExpr)
	 */
	protected void sequence_XpathEqualityExpr(ISerializationContext context, XpathEqualityOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns UnparsedXpath
	 *     ParsedXpathExpression returns UnparsedXpath
	 *     XpathOrExpr returns UnparsedXpath
	 *     XpathOrExpr.XpathOrOperation_1_0 returns UnparsedXpath
	 *     XpathAndExpr returns UnparsedXpath
	 *     XpathAndExpr.XpathAndOperation_1_0 returns UnparsedXpath
	 *     XpathEqualityExpr returns UnparsedXpath
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns UnparsedXpath
	 *     XpathRelationalExpr returns UnparsedXpath
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns UnparsedXpath
	 *     XpathAdditiveExpr returns UnparsedXpath
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns UnparsedXpath
	 *     XpathMultiplicativeExpr returns UnparsedXpath
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns UnparsedXpath
	 *     XpathUnaryExpr returns UnparsedXpath
	 *     XpathUnionExpr returns UnparsedXpath
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns UnparsedXpath
	 *     XpathPathExpr returns UnparsedXpath
	 *     XpathPathExpr.XpathLocation_1_0 returns UnparsedXpath
	 *     XpathFilterExpr returns UnparsedXpath
	 *     XpathFilterExpr.XpathFilter_1_0 returns UnparsedXpath
	 *     XpathPrimaryExpr returns UnparsedXpath
	 *
	 * Constraint:
	 *     text=STRING
	 */
	protected void sequence_XpathExpression(ISerializationContext context, UnparsedXpath semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.UNPARSED_XPATH__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.UNPARSED_XPATH__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathExpressionAccess().getTextSTRINGTerminalRuleCall_0_2_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns XpathFilter
	 *     ParsedXpathExpression returns XpathFilter
	 *     XpathOrExpr returns XpathFilter
	 *     XpathOrExpr.XpathOrOperation_1_0 returns XpathFilter
	 *     XpathAndExpr returns XpathFilter
	 *     XpathAndExpr.XpathAndOperation_1_0 returns XpathFilter
	 *     XpathEqualityExpr returns XpathFilter
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns XpathFilter
	 *     XpathRelationalExpr returns XpathFilter
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns XpathFilter
	 *     XpathAdditiveExpr returns XpathFilter
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns XpathFilter
	 *     XpathMultiplicativeExpr returns XpathFilter
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns XpathFilter
	 *     XpathUnaryExpr returns XpathFilter
	 *     XpathUnionExpr returns XpathFilter
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns XpathFilter
	 *     XpathPathExpr returns XpathFilter
	 *     XpathPathExpr.XpathLocation_1_0 returns XpathFilter
	 *     XpathFilterExpr returns XpathFilter
	 *     XpathFilterExpr.XpathFilter_1_0 returns XpathFilter
	 *     XpathPrimaryExpr returns XpathFilter
	 *
	 * Constraint:
	 *     ((target=XpathPathExpr_XpathFilter_1_4_0 predicate=XpathExpression) | (target=XpathFilterExpr_XpathFilter_1_0 predicate=XpathExpression))
	 */
	protected void sequence_XpathFilterExpr_XpathPathExpr(ISerializationContext context, XpathFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns XpathMultiplicativeOperation
	 *     ParsedXpathExpression returns XpathMultiplicativeOperation
	 *     XpathOrExpr returns XpathMultiplicativeOperation
	 *     XpathOrExpr.XpathOrOperation_1_0 returns XpathMultiplicativeOperation
	 *     XpathAndExpr returns XpathMultiplicativeOperation
	 *     XpathAndExpr.XpathAndOperation_1_0 returns XpathMultiplicativeOperation
	 *     XpathEqualityExpr returns XpathMultiplicativeOperation
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns XpathMultiplicativeOperation
	 *     XpathRelationalExpr returns XpathMultiplicativeOperation
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns XpathMultiplicativeOperation
	 *     XpathAdditiveExpr returns XpathMultiplicativeOperation
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns XpathMultiplicativeOperation
	 *     XpathMultiplicativeExpr returns XpathMultiplicativeOperation
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns XpathMultiplicativeOperation
	 *     XpathUnaryExpr returns XpathMultiplicativeOperation
	 *     XpathUnionExpr returns XpathMultiplicativeOperation
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns XpathMultiplicativeOperation
	 *     XpathPathExpr returns XpathMultiplicativeOperation
	 *     XpathPathExpr.XpathLocation_1_0 returns XpathMultiplicativeOperation
	 *     XpathFilterExpr returns XpathMultiplicativeOperation
	 *     XpathFilterExpr.XpathFilter_1_0 returns XpathMultiplicativeOperation
	 *     XpathPrimaryExpr returns XpathMultiplicativeOperation
	 *
	 * Constraint:
	 *     (left=XpathMultiplicativeExpr_XpathMultiplicativeOperation_1_0 (operator='*' | operator='div' | operator='mod') right=XpathMultiplicativeExpr)
	 */
	protected void sequence_XpathMultiplicativeExpr(ISerializationContext context, XpathMultiplicativeOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XpathNodeTest returns XpathNameTest
	 *     XpathNameTest returns XpathNameTest
	 *
	 * Constraint:
	 *     (prefix=ID? ref=[SchemaNode|XpathIDOrKw])
	 */
	protected void sequence_XpathNameTest(ISerializationContext context, XpathNameTest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XpathNodeTest returns ProcessingInstruction
	 *
	 * Constraint:
	 *     instruction=STRING
	 */
	protected void sequence_XpathNodeTest(ISerializationContext context, ProcessingInstruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.PROCESSING_INSTRUCTION__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.PROCESSING_INSTRUCTION__INSTRUCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathNodeTestAccess().getInstructionSTRINGTerminalRuleCall_2_3_0(), semanticObject.getInstruction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XpathNodeTest returns XpathNodeType
	 *
	 * Constraint:
	 *     name=XpathNodeType
	 */
	protected void sequence_XpathNodeTest(ISerializationContext context, XpathNodeType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_NODE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_NODE_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathNodeTestAccess().getNameXpathNodeTypeParserRuleCall_1_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns XpathOrOperation
	 *     ParsedXpathExpression returns XpathOrOperation
	 *     XpathOrExpr returns XpathOrOperation
	 *     XpathOrExpr.XpathOrOperation_1_0 returns XpathOrOperation
	 *     XpathAndExpr returns XpathOrOperation
	 *     XpathAndExpr.XpathAndOperation_1_0 returns XpathOrOperation
	 *     XpathEqualityExpr returns XpathOrOperation
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns XpathOrOperation
	 *     XpathRelationalExpr returns XpathOrOperation
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns XpathOrOperation
	 *     XpathAdditiveExpr returns XpathOrOperation
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns XpathOrOperation
	 *     XpathMultiplicativeExpr returns XpathOrOperation
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns XpathOrOperation
	 *     XpathUnaryExpr returns XpathOrOperation
	 *     XpathUnionExpr returns XpathOrOperation
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns XpathOrOperation
	 *     XpathPathExpr returns XpathOrOperation
	 *     XpathPathExpr.XpathLocation_1_0 returns XpathOrOperation
	 *     XpathFilterExpr returns XpathOrOperation
	 *     XpathFilterExpr.XpathFilter_1_0 returns XpathOrOperation
	 *     XpathPrimaryExpr returns XpathOrOperation
	 *
	 * Constraint:
	 *     (left=XpathOrExpr_XpathOrOperation_1_0 operator='or' right=XpathAndExpr)
	 */
	protected void sequence_XpathOrExpr(ISerializationContext context, XpathOrOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_OR_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_OR_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_OR_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_OR_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_OR_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_OR_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathOrExprAccess().getXpathOrOperationLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXpathOrExprAccess().getOperatorOrKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getXpathOrExprAccess().getRightXpathAndExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XpathPathExpr.XpathFilter_1_4_0 returns XpathFilter
	 *
	 * Constraint:
	 *     (target=XpathPathExpr_XpathFilter_1_4_0 predicate=XpathExpression)
	 */
	protected void sequence_XpathPathExpr_XpathFilter_1_4_0(ISerializationContext context, XpathFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_FILTER__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_FILTER__TARGET));
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_FILTER__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_FILTER__PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathPathExprAccess().getXpathFilterTargetAction_1_4_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getXpathPathExprAccess().getPredicateXpathExpressionParserRuleCall_1_4_2_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns XpathLocation
	 *     ParsedXpathExpression returns XpathLocation
	 *     XpathOrExpr returns XpathLocation
	 *     XpathOrExpr.XpathOrOperation_1_0 returns XpathLocation
	 *     XpathAndExpr returns XpathLocation
	 *     XpathAndExpr.XpathAndOperation_1_0 returns XpathLocation
	 *     XpathEqualityExpr returns XpathLocation
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns XpathLocation
	 *     XpathRelationalExpr returns XpathLocation
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns XpathLocation
	 *     XpathAdditiveExpr returns XpathLocation
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns XpathLocation
	 *     XpathMultiplicativeExpr returns XpathLocation
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns XpathLocation
	 *     XpathUnaryExpr returns XpathLocation
	 *     XpathUnionExpr returns XpathLocation
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns XpathLocation
	 *     XpathPathExpr returns XpathLocation
	 *     XpathPathExpr.XpathLocation_1_0 returns XpathLocation
	 *     XpathPathExpr.XpathFilter_1_4_0 returns XpathLocation
	 *     XpathFilterExpr returns XpathLocation
	 *     XpathFilterExpr.XpathFilter_1_0 returns XpathLocation
	 *     XpathPrimaryExpr returns XpathLocation
	 *
	 * Constraint:
	 *     (target=XpathPathExpr_XpathLocation_1_0 isDescendants?='/'? step=XpathStep)
	 */
	protected void sequence_XpathPathExpr(ISerializationContext context, XpathLocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns AbsolutePath
	 *     ParsedXpathExpression returns AbsolutePath
	 *     XpathOrExpr returns AbsolutePath
	 *     XpathOrExpr.XpathOrOperation_1_0 returns AbsolutePath
	 *     XpathAndExpr returns AbsolutePath
	 *     XpathAndExpr.XpathAndOperation_1_0 returns AbsolutePath
	 *     XpathEqualityExpr returns AbsolutePath
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns AbsolutePath
	 *     XpathRelationalExpr returns AbsolutePath
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns AbsolutePath
	 *     XpathAdditiveExpr returns AbsolutePath
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns AbsolutePath
	 *     XpathMultiplicativeExpr returns AbsolutePath
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns AbsolutePath
	 *     XpathUnaryExpr returns AbsolutePath
	 *     XpathUnionExpr returns AbsolutePath
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns AbsolutePath
	 *     XpathPathExpr returns AbsolutePath
	 *     XpathPathExpr.XpathLocation_1_0 returns AbsolutePath
	 *     XpathFilterExpr returns AbsolutePath
	 *     XpathFilterExpr.XpathFilter_1_0 returns AbsolutePath
	 *     XpathPrimaryExpr returns AbsolutePath
	 *
	 * Constraint:
	 *     (isDescendants?='/'? step=XpathStep?)
	 */
	protected void sequence_XpathPrimaryExpr(ISerializationContext context, AbsolutePath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns RelativePath
	 *     ParsedXpathExpression returns RelativePath
	 *     XpathOrExpr returns RelativePath
	 *     XpathOrExpr.XpathOrOperation_1_0 returns RelativePath
	 *     XpathAndExpr returns RelativePath
	 *     XpathAndExpr.XpathAndOperation_1_0 returns RelativePath
	 *     XpathEqualityExpr returns RelativePath
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns RelativePath
	 *     XpathRelationalExpr returns RelativePath
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns RelativePath
	 *     XpathAdditiveExpr returns RelativePath
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns RelativePath
	 *     XpathMultiplicativeExpr returns RelativePath
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns RelativePath
	 *     XpathUnaryExpr returns RelativePath
	 *     XpathUnionExpr returns RelativePath
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns RelativePath
	 *     XpathPathExpr returns RelativePath
	 *     XpathPathExpr.XpathLocation_1_0 returns RelativePath
	 *     XpathFilterExpr returns RelativePath
	 *     XpathFilterExpr.XpathFilter_1_0 returns RelativePath
	 *     XpathPrimaryExpr returns RelativePath
	 *
	 * Constraint:
	 *     step=XpathStep
	 */
	protected void sequence_XpathPrimaryExpr(ISerializationContext context, RelativePath semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.RELATIVE_PATH__STEP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.RELATIVE_PATH__STEP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathPrimaryExprAccess().getStepXpathStepParserRuleCall_5_1_0(), semanticObject.getStep());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns XpathFunctionCall
	 *     ParsedXpathExpression returns XpathFunctionCall
	 *     XpathOrExpr returns XpathFunctionCall
	 *     XpathOrExpr.XpathOrOperation_1_0 returns XpathFunctionCall
	 *     XpathAndExpr returns XpathFunctionCall
	 *     XpathAndExpr.XpathAndOperation_1_0 returns XpathFunctionCall
	 *     XpathEqualityExpr returns XpathFunctionCall
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns XpathFunctionCall
	 *     XpathRelationalExpr returns XpathFunctionCall
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns XpathFunctionCall
	 *     XpathAdditiveExpr returns XpathFunctionCall
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns XpathFunctionCall
	 *     XpathMultiplicativeExpr returns XpathFunctionCall
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns XpathFunctionCall
	 *     XpathUnaryExpr returns XpathFunctionCall
	 *     XpathUnionExpr returns XpathFunctionCall
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns XpathFunctionCall
	 *     XpathPathExpr returns XpathFunctionCall
	 *     XpathPathExpr.XpathLocation_1_0 returns XpathFunctionCall
	 *     XpathFilterExpr returns XpathFunctionCall
	 *     XpathFilterExpr.XpathFilter_1_0 returns XpathFunctionCall
	 *     XpathPrimaryExpr returns XpathFunctionCall
	 *
	 * Constraint:
	 *     (name=QNAME (args+=XpathExpression args+=XpathExpression*)?)
	 */
	protected void sequence_XpathPrimaryExpr(ISerializationContext context, XpathFunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns XpathNumberLiteral
	 *     ParsedXpathExpression returns XpathNumberLiteral
	 *     XpathOrExpr returns XpathNumberLiteral
	 *     XpathOrExpr.XpathOrOperation_1_0 returns XpathNumberLiteral
	 *     XpathAndExpr returns XpathNumberLiteral
	 *     XpathAndExpr.XpathAndOperation_1_0 returns XpathNumberLiteral
	 *     XpathEqualityExpr returns XpathNumberLiteral
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns XpathNumberLiteral
	 *     XpathRelationalExpr returns XpathNumberLiteral
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns XpathNumberLiteral
	 *     XpathAdditiveExpr returns XpathNumberLiteral
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns XpathNumberLiteral
	 *     XpathMultiplicativeExpr returns XpathNumberLiteral
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns XpathNumberLiteral
	 *     XpathUnaryExpr returns XpathNumberLiteral
	 *     XpathUnionExpr returns XpathNumberLiteral
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns XpathNumberLiteral
	 *     XpathPathExpr returns XpathNumberLiteral
	 *     XpathPathExpr.XpathLocation_1_0 returns XpathNumberLiteral
	 *     XpathFilterExpr returns XpathNumberLiteral
	 *     XpathFilterExpr.XpathFilter_1_0 returns XpathNumberLiteral
	 *     XpathPrimaryExpr returns XpathNumberLiteral
	 *
	 * Constraint:
	 *     value=NUMBER
	 */
	protected void sequence_XpathPrimaryExpr(ISerializationContext context, XpathNumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_NUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_NUMBER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathPrimaryExprAccess().getValueNUMBERTerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns XpathStringLiteral
	 *     ParsedXpathExpression returns XpathStringLiteral
	 *     XpathOrExpr returns XpathStringLiteral
	 *     XpathOrExpr.XpathOrOperation_1_0 returns XpathStringLiteral
	 *     XpathAndExpr returns XpathStringLiteral
	 *     XpathAndExpr.XpathAndOperation_1_0 returns XpathStringLiteral
	 *     XpathEqualityExpr returns XpathStringLiteral
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns XpathStringLiteral
	 *     XpathRelationalExpr returns XpathStringLiteral
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns XpathStringLiteral
	 *     XpathAdditiveExpr returns XpathStringLiteral
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns XpathStringLiteral
	 *     XpathMultiplicativeExpr returns XpathStringLiteral
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns XpathStringLiteral
	 *     XpathUnaryExpr returns XpathStringLiteral
	 *     XpathUnionExpr returns XpathStringLiteral
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns XpathStringLiteral
	 *     XpathPathExpr returns XpathStringLiteral
	 *     XpathPathExpr.XpathLocation_1_0 returns XpathStringLiteral
	 *     XpathFilterExpr returns XpathStringLiteral
	 *     XpathFilterExpr.XpathFilter_1_0 returns XpathStringLiteral
	 *     XpathPrimaryExpr returns XpathStringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_XpathPrimaryExpr(ISerializationContext context, XpathStringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathPrimaryExprAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns XpathVariableReference
	 *     ParsedXpathExpression returns XpathVariableReference
	 *     XpathOrExpr returns XpathVariableReference
	 *     XpathOrExpr.XpathOrOperation_1_0 returns XpathVariableReference
	 *     XpathAndExpr returns XpathVariableReference
	 *     XpathAndExpr.XpathAndOperation_1_0 returns XpathVariableReference
	 *     XpathEqualityExpr returns XpathVariableReference
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns XpathVariableReference
	 *     XpathRelationalExpr returns XpathVariableReference
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns XpathVariableReference
	 *     XpathAdditiveExpr returns XpathVariableReference
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns XpathVariableReference
	 *     XpathMultiplicativeExpr returns XpathVariableReference
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns XpathVariableReference
	 *     XpathUnaryExpr returns XpathVariableReference
	 *     XpathUnionExpr returns XpathVariableReference
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns XpathVariableReference
	 *     XpathPathExpr returns XpathVariableReference
	 *     XpathPathExpr.XpathLocation_1_0 returns XpathVariableReference
	 *     XpathFilterExpr returns XpathVariableReference
	 *     XpathFilterExpr.XpathFilter_1_0 returns XpathVariableReference
	 *     XpathPrimaryExpr returns XpathVariableReference
	 *
	 * Constraint:
	 *     name=QNAME
	 */
	protected void sequence_XpathPrimaryExpr(ISerializationContext context, XpathVariableReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_VARIABLE_REFERENCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_VARIABLE_REFERENCE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathPrimaryExprAccess().getNameQNAMEParserRuleCall_0_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns XpathRelationalOperation
	 *     ParsedXpathExpression returns XpathRelationalOperation
	 *     XpathOrExpr returns XpathRelationalOperation
	 *     XpathOrExpr.XpathOrOperation_1_0 returns XpathRelationalOperation
	 *     XpathAndExpr returns XpathRelationalOperation
	 *     XpathAndExpr.XpathAndOperation_1_0 returns XpathRelationalOperation
	 *     XpathEqualityExpr returns XpathRelationalOperation
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns XpathRelationalOperation
	 *     XpathRelationalExpr returns XpathRelationalOperation
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns XpathRelationalOperation
	 *     XpathAdditiveExpr returns XpathRelationalOperation
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns XpathRelationalOperation
	 *     XpathMultiplicativeExpr returns XpathRelationalOperation
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns XpathRelationalOperation
	 *     XpathUnaryExpr returns XpathRelationalOperation
	 *     XpathUnionExpr returns XpathRelationalOperation
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns XpathRelationalOperation
	 *     XpathPathExpr returns XpathRelationalOperation
	 *     XpathPathExpr.XpathLocation_1_0 returns XpathRelationalOperation
	 *     XpathFilterExpr returns XpathRelationalOperation
	 *     XpathFilterExpr.XpathFilter_1_0 returns XpathRelationalOperation
	 *     XpathPrimaryExpr returns XpathRelationalOperation
	 *
	 * Constraint:
	 *     (left=XpathRelationalExpr_XpathRelationalOperation_1_0 (operator='<' | operator='>' | operator='<=' | operator='>=') right=XpathAdditiveExpr)
	 */
	protected void sequence_XpathRelationalExpr(ISerializationContext context, XpathRelationalOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XpathStep returns AbbrevAttributeStep
	 *
	 * Constraint:
	 *     attributeName=XpathIDOrKw
	 */
	protected void sequence_XpathStep(ISerializationContext context, AbbrevAttributeStep semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.ABBREV_ATTRIBUTE_STEP__ATTRIBUTE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.ABBREV_ATTRIBUTE_STEP__ATTRIBUTE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathStepAccess().getAttributeNameXpathIDOrKwParserRuleCall_2_2_0(), semanticObject.getAttributeName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XpathStep returns CurrentRef
	 *
	 * Constraint:
	 *     ref=[SchemaNode|Dot]
	 */
	protected void sequence_XpathStep(ISerializationContext context, CurrentRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.CURRENT_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.CURRENT_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathStepAccess().getRefSchemaNodeDotParserRuleCall_0_1_0_1(), semanticObject.eGet(YangPackage.Literals.CURRENT_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XpathStep returns ParentRef
	 *
	 * Constraint:
	 *     ref=[SchemaNode|DotDot]
	 */
	protected void sequence_XpathStep(ISerializationContext context, ParentRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.PARENT_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.PARENT_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathStepAccess().getRefSchemaNodeDotDotParserRuleCall_1_1_0_1(), semanticObject.eGet(YangPackage.Literals.PARENT_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XpathStep returns XpathStep
	 *
	 * Constraint:
	 *     (axis=XpathAxisName? node=XpathNodeTest)
	 */
	protected void sequence_XpathStep(ISerializationContext context, XpathStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns XpathUnaryOperation
	 *     ParsedXpathExpression returns XpathUnaryOperation
	 *     XpathOrExpr returns XpathUnaryOperation
	 *     XpathOrExpr.XpathOrOperation_1_0 returns XpathUnaryOperation
	 *     XpathAndExpr returns XpathUnaryOperation
	 *     XpathAndExpr.XpathAndOperation_1_0 returns XpathUnaryOperation
	 *     XpathEqualityExpr returns XpathUnaryOperation
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns XpathUnaryOperation
	 *     XpathRelationalExpr returns XpathUnaryOperation
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns XpathUnaryOperation
	 *     XpathAdditiveExpr returns XpathUnaryOperation
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns XpathUnaryOperation
	 *     XpathMultiplicativeExpr returns XpathUnaryOperation
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns XpathUnaryOperation
	 *     XpathUnaryExpr returns XpathUnaryOperation
	 *     XpathUnionExpr returns XpathUnaryOperation
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns XpathUnaryOperation
	 *     XpathPathExpr returns XpathUnaryOperation
	 *     XpathPathExpr.XpathLocation_1_0 returns XpathUnaryOperation
	 *     XpathFilterExpr returns XpathUnaryOperation
	 *     XpathFilterExpr.XpathFilter_1_0 returns XpathUnaryOperation
	 *     XpathPrimaryExpr returns XpathUnaryOperation
	 *
	 * Constraint:
	 *     (operator='-' target=XpathUnionExpr)
	 */
	protected void sequence_XpathUnaryExpr(ISerializationContext context, XpathUnaryOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_UNARY_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_UNARY_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_UNARY_OPERATION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_UNARY_OPERATION__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathUnaryExprAccess().getOperatorHyphenMinusKeyword_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getXpathUnaryExprAccess().getTargetXpathUnionExprParserRuleCall_0_2_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XpathExpression returns XpathUnionOperation
	 *     ParsedXpathExpression returns XpathUnionOperation
	 *     XpathOrExpr returns XpathUnionOperation
	 *     XpathOrExpr.XpathOrOperation_1_0 returns XpathUnionOperation
	 *     XpathAndExpr returns XpathUnionOperation
	 *     XpathAndExpr.XpathAndOperation_1_0 returns XpathUnionOperation
	 *     XpathEqualityExpr returns XpathUnionOperation
	 *     XpathEqualityExpr.XpathEqualityOperation_1_0 returns XpathUnionOperation
	 *     XpathRelationalExpr returns XpathUnionOperation
	 *     XpathRelationalExpr.XpathRelationalOperation_1_0 returns XpathUnionOperation
	 *     XpathAdditiveExpr returns XpathUnionOperation
	 *     XpathAdditiveExpr.XpathAdditiveOperation_1_0 returns XpathUnionOperation
	 *     XpathMultiplicativeExpr returns XpathUnionOperation
	 *     XpathMultiplicativeExpr.XpathMultiplicativeOperation_1_0 returns XpathUnionOperation
	 *     XpathUnaryExpr returns XpathUnionOperation
	 *     XpathUnionExpr returns XpathUnionOperation
	 *     XpathUnionExpr.XpathUnionOperation_1_0 returns XpathUnionOperation
	 *     XpathPathExpr returns XpathUnionOperation
	 *     XpathPathExpr.XpathLocation_1_0 returns XpathUnionOperation
	 *     XpathFilterExpr returns XpathUnionOperation
	 *     XpathFilterExpr.XpathFilter_1_0 returns XpathUnionOperation
	 *     XpathPrimaryExpr returns XpathUnionOperation
	 *
	 * Constraint:
	 *     (left=XpathUnionExpr_XpathUnionOperation_1_0 operator='|' right=XpathUnionExpr)
	 */
	protected void sequence_XpathUnionExpr(ISerializationContext context, XpathUnionOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_UNION_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_UNION_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_UNION_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_UNION_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, YangPackage.Literals.XPATH_UNION_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YangPackage.Literals.XPATH_UNION_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXpathUnionExprAccess().getXpathUnionOperationLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXpathUnionExprAccess().getOperatorVerticalLineKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getXpathUnionExprAccess().getRightXpathUnionExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
