/*
 * generated by Xtext 2.16.0-SNAPSHOT
 */
lexer grammar InternalYangLexer;

@header {
package io.typefox.yang.parser.antlr.lexer;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}

ProcessingInstruction : 'processing-instruction';

InstanceIdentifier : 'instance-identifier';

DescendantOrSelf : 'descendant-or-self';

FollowingSibling : 'following-sibling';

PrecedingSibling : 'preceding-sibling';

AncestorOrSelf : 'ancestor-or-self';

RequireInstance : 'require-instance';

FractionDigits : 'fraction-digits';

ErrorAppTag : 'error-app-tag';

ErrorMessage : 'error-message';

NotSupported : 'not-supported';

RevisionDate : 'revision-date';

MaxElements : 'max-elements';

MinElements : 'min-elements';

Notification : 'notification';

Organization : 'organization';

YangVersion : 'yang-version';

Description : 'description';

Enumeration : 'enumeration';

Identityref : 'identityref';

YinElement : 'yin-element';

BelongsTo : 'belongs-to';

Deprecated : 'deprecated';

Descendant : 'descendant';

IfFeature : 'if-feature';

OrderedBy : 'ordered-by';

Attribute : 'attribute';

Container : 'container';

Decimal64 : 'decimal64';

Deviation : 'deviation';

Extension : 'extension';

Following : 'following';

LeafList : 'leaf-list';

Mandatory : 'mandatory';

Namespace : 'namespace';

Preceding : 'preceding';

Reference : 'reference';

Submodule : 'submodule';

Unbounded : 'unbounded';

Ancestor : 'ancestor';

Argument : 'argument';

Grouping : 'grouping';

Identity : 'identity';

Modifier : 'modifier';

Obsolete : 'obsolete';

Position : 'position';

Presence : 'presence';

Revision : 'revision';

Anydata : 'anydata';

Augment : 'augment';

Boolean : 'boolean';

Comment : 'comment';

Contact : 'contact';

Current : 'current';

Default : 'default';

Deviate : 'deviate';

Feature : 'feature';

Include : 'include';

Leafref : 'leafref';

Pattern : 'pattern';

Replace : 'replace';

Typedef : 'typedef';

Action : 'action';

Anyxml : 'anyxml';

Binary : 'binary';

Choice : 'choice';

Config : 'config';

Delete : 'delete';

Import : 'import';

Length : 'length';

Module : 'module';

Output : 'output';

Parent : 'parent';

Prefix : 'prefix';

Refine : 'refine';

Status : 'status';

String : 'string';

KW_System : 'system';

Uint16 : 'uint16';

Uint32 : 'uint32';

Uint64 : 'uint64';

Unique : 'unique';

Child : 'child';

Empty : 'empty';

False : 'false';

Input : 'input';

Int16 : 'int16';

Int32 : 'int32';

Int64 : 'int64';

Range : 'range';

Uint8 : 'uint8';

Union : 'union';

Units : 'units';

Value : 'value';

LessThanSignLessThanSignLessThanSignLessThanSign : '<<<<';

GreaterThanSignGreaterThanSignGreaterThanSignGreaterThanSign : '>>>>';

Base : 'base';

Bits : 'bits';

Case : 'case';

Enum : 'enum';

Int8 : 'int8';

Leaf : 'leaf';

List : 'list';

Must : 'must';

Node : 'node';

Path : 'path';

Self : 'self';

Text : 'text';

True : 'true';

Type : 'type';

User : 'user';

Uses : 'uses';

When : 'when';

Add : 'add';

And : 'and';

Bit : 'bit';

Div : 'div';

Key : 'key';

Max : 'max';

Min : 'min';

Mod : 'mod';

Not : 'not';

Rpc : 'rpc';

ExclamationMarkEqualsSign : '!=';

FullStopFullStop : '..';

LessThanSignEqualsSign : '<=';

GreaterThanSignEqualsSign : '>=';

Or : 'or';

DollarSign : '$';

LeftParenthesis : '(';

RightParenthesis : ')';

Asterisk : '*';

PlusSign : '+';

Comma : ',';

HyphenMinus : '-';

FullStop : '.';

Solidus : '/';

Colon : ':';

Semicolon : ';';

LessThanSign : '<';

EqualsSign : '=';

GreaterThanSign : '>';

CommercialAt : '@';

LeftSquareBracket : '[';

RightSquareBracket : ']';

LeftCurlyBracket : '{';

VerticalLine : '|';

RightCurlyBracket : '}';

RULE_ID : 'an id';

RULE_EXTENSION_NAME : 'ID:ID // only valid on statement ctx';

RULE_STRING : 'an unquoted string';

RULE_NUMBER : 'positive integer value';

RULE_OPERATOR : ('and'|'or'|'mod'|'div'|'*'|'/'|'//'|'|'|'+'|'-'|'='|'!='|'<'|'<='|'>'|'>=');

RULE_ML_COMMENT : '/*' ( options {greedy=false;} : . )*'*/';

RULE_SL_COMMENT : '//' ~(('\n'|'\r'))* ('\r'? '\n')?;

RULE_WS : (' '|'\t'|'\r'|'\n')+;

RULE_HIDDEN : 'other hidden tokens';

RULE_ANY_OTHER : .;
